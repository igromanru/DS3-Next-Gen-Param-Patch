<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="24">
  <CheatEntries>
    <CheatEntry>
      <ID>249</ID>
      <Description>"ParamUtils"</Description>
      <Options moHideChildren="1"/>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
{$lua}
--if syntaxcheck then return end

--[[START PatchInfo class
	Author: Igromanru
	Description: Entity with informations (address, value and valueType).
					Also enum TYPE, with all possible value types.
]]--
PatchInfo = {
	address = 0,
	value = 0,
	valueType = 0,
	binaryOffset = 0,
	BINARYOFFSET = {
		ONE = 1,
		TWO = 2,
		THREE = 4,
		FOUR = 8,
		FIVE = 16,
		SIX = 32,
		SEVEN = 64,
		EIGHT = 128,
	},
	TYPE = {
		BINARY = 0,
		BYTE = 1,
		TWO_BYTE = 2,
		FOUR_BYTE = 3,
		EIGHT_BYTE = 4,
		FLOAT = 5,
	}
}

function PatchInfo:new(address, value, valueType, binaryOffset)
	local o = {}
	setmetatable(o, self)
	self.__index = self
	if(address ~= nil) then
		o.address = address
	end
	if(value ~= nil) then
		o.value = value
	end
	if(valueType ~= nil) then
		o.valueType = valueType
	end
	if(binaryOffset ~= nil) then
		o.binaryOffset = binaryOffset
	end

	return o
end

function PatchInfo:getBinaryOffset(value)
	local result = value
	if(value == 0) then
		result = PatchInfo.BINARYOFFSET.ONE
	elseif(value == 1) then
		result = PatchInfo.BINARYOFFSET.TWO
	elseif(value == 2) then
		result = PatchInfo.BINARYOFFSET.THREE
	elseif(value == 3) then
		result = PatchInfo.BINARYOFFSET.FOUR
	elseif(value == 4) then
		result = PatchInfo.BINARYOFFSET.FIVE
	elseif(value == 5) then
		result = PatchInfo.BINARYOFFSET.SIX
	elseif(value == 6) then
		result = PatchInfo.BINARYOFFSET.SEVEN
	elseif(value == 7) then
		result = PatchInfo.BINARYOFFSET.EIGHT
	end
	return result
end

--[[END PatchInfo class]]--

--[[START ParamUtils class
	Author: Igromanru
	Description: Utils class for Params
]]--
ParamUtils = {
	masterParamTable = {},
	patchBackUp = {},
    patchBackUpOld = {},
}

function ParamUtils:new()
	local function readIntegerSafe(Input)
		local Value = readInteger(Input)
		if Value &lt; 2147483647 then
			return Value
		else
			return Value - 0x100000000
		end
	end
	local function InitializeAddress()
		autoAssemble([[
			aobscanmodule(ParamPatchBase,DarkSoulsIII.exe,48 8B 0D ? ? ? ? 48 85 C9 74 0B 4C 8B C0 48 8B D7)
			registersymbol(ParamPatchBase)
		]])
		local addr = getAddress("ParamPatchBase")
		addr = addr + readIntegerSafe(addr + 0x3) + 7
		addr = readQword(addr)+ 0x10
		unregisterSymbol("ParamPatch")
		registerSymbol("ParamPatch", addr, true)
	end
	local o = {}
	setmetatable(o, self)
	self.__index = self

    InitializeAddress()
	o:paramIndexer()
	return o
end

function ParamUtils:destroy()
	unregisterSymbol("ParamPatchBase")
	unregisterSymbol("ParamPatch")
end

function ParamUtils:toHex(number, length)
	local result = ""
	if(length ~= nil and length &gt; 0) then
		result = string.format("%0"..length.."X",number)
	else
		result = string.format("%X",number)
	end
	return result
end

function ParamUtils:logError(message)
	local output = "ParamUtils Error:\r\n"..message
	print(output)
	error(output)
end

function ParamUtils:paramIndexer()
	local Param = getAddress("ParamPatch")
	local Start = readQword(Param)
	local End = readQword(Param+8)
	local Count = (End-Start)/8
	self.masterParamTable = {}

	for i = 0, Count - 1 do
	  local ParamOffset = readQword(Start+i*8)
	  local ParamString = "Unknown"
	  if readInteger(ParamOffset+0x20) &gt; 7 then
		 ParamString = readString(readQword(ParamOffset+0x10),90,true)
	  else
		 ParamString = readString(ParamOffset+0x10,90,true)
	  end
	  self.masterParamTable[ParamString] = ParamOffset
	end
end

function ParamUtils:getIdAddress(IdTable, Id)
	local result = IdTable[Id]
	if(result == nil or result &lt; 0) then
		self:logError("ID: "..Id.." (0x"..self:toHex(Id) ..") couldn't be found")
	end
	return result
end

function ParamUtils:getParamIdTable(ParamName)
	local IDTable = {}
	local ParamAddr = readQword(readQword(self.masterParamTable[ParamName]+0x68)+0x68)
	local TableCount = byteTableToWord(readBytes(ParamAddr+0xa,2,true))
	for i=0,TableCount-1 do
		local PID = readInteger(ParamAddr+0x40+0x18*i)
		local IDO = readInteger(ParamAddr+0x48+0x18*i)
		IDTable[PID] = ParamAddr + IDO
	end
	return IDTable
end

function ParamUtils:getIdAddressFromParam(paramName, id)
	local result = 0
	local idTable = self:getParamIdTable(paramName)

	if(idTable ~= nil) then
		result = self:getIdAddress(idTable, id)
	else
		self:logError("Addresses for Param: '"..paramName.."' couldn't be found")
	end
	return result
end

function ParamUtils:getAllAddressFromParam(paramName)
	local result = {}
	local idTable = self:getParamIdTable(paramName)

	if(idTable ~= nil) then
		for id,address in pairs(idTable) do
			table.insert(result, address)
		end
	end
	return result
end

function ParamUtils:paramIterator(ParamName,ChangeTable,uuid)
	local IDTable = self:getParamIdTable(ParamName)
	if uuid ~= nil then --Make a table for backups
		if self.patchBackUpOld == nil then
			self.patchBackUpOld = {}
		end
		self.patchBackUpOld[uuid] = {}
		for k,v in pairs(ChangeTable) do
			local Backup = {}
			local _,DataLength = string.gsub(v[3], "%x+","")
			local idAddress = self:getIdAddress(IDTable,v[1])
			if idAddress ~= nil then
				Backup[1] = idAddress + v[2]
				Backup[2] = readBytes(Backup[1],DataLength,true)
				table.insert(self.patchBackUpOld[uuid],Backup)
				self:paramPatcher(idAddress,v[2],v[3],v[4])
			end
		end
	else
		for k,v in pairs(ChangeTable) do
			local idAddress = getIdAddress(IDTable,v[1])
			if idAddress ~= nil then
				self:paramPatcher(idAddress,v[2],v[3],v[4])
			end
		end
	end
end

function ParamUtils:paramPatcher(idAddress,DataOffset,Data,Symbol)
	local WriteAddr = idAddress+DataOffset
	local HexTable = {}
	if Symbol == nil then
		for word in string.gmatch(Data, "%x+") do table.insert(HexTable,tonumber(word,16)) end
		writeBytes(WriteAddr,HexTable)
	else
		registerSymbol(Symbol,WriteAddr,true)
	end
end

function ParamUtils:paramDepatcher(uuid)
	for k,v in pairs(self.patchBackUpOld[uuid]) do
		writeBytes(v[1],v[2])
	end
	self.patchBackUpOld[uuid] = nil
end

function ParamUtils:patchMultipleOffsets(paramName, id, patchInfoTable, uuid)
	if(self.patchBackUp[uuid] == nil) then
		local address = getIdAddressFromParam()
		for key,patchInfo in pairs(patchInfoTable) do
			patchInfo.address = address
			self:patchValueWithBackup(patchInfo,uuid)
		end
	else
        self:logError("The UUID "..uuid.." is already in use.")
	end
end

function ParamUtils:restore(...)
	local arg = table.pack(...)
	for i,uuid in ipairs(arg) do
		for index,patchInfo in ipairs(self.patchBackUp[uuid]) do
			self:patchValue(patchInfo)
		end
		self.patchBackUp[uuid] = nil
	end
end

function ParamUtils:patchValueWithBackup(patchInfo, uuid)
	local readValue = self:readValue(patchInfo)
	local backup = true

	self:patchValue(patchInfo)

	for i,object in ipairs(self.patchBackUp[uuid]) do
		if(object.address == patchInfo.address) then
			backup = false
			break
		end
	end
	if(backup) then
		if(patchInfo.valueType == PatchInfo.TYPE.BINARY) then
			patchInfo.valueType = PatchInfo.TYPE.BYTE
		end
		table.insert(self.patchBackUp[uuid], PatchInfo:new(patchInfo.address, readValue, patchInfo.valueType))
	end
end

function ParamUtils:readValue(patchInfo)
	local value = 0
	if(patchInfo.valueType == PatchInfo.TYPE.BYTE or patchInfo.valueType == PatchInfo.TYPE.BINARY) then
		value = self:readByte(patchInfo)
	elseif(patchInfo.valueType == PatchInfo.TYPE.TWO_BYTE) then
		value = self:read2Byte(patchInfo)
	elseif(patchInfo.valueType == PatchInfo.TYPE.FOUR_BYTE) then
		value = self:read4Byte(patchInfo)
	elseif(patchInfo.valueType == PatchInfo.TYPE.EIGHT_BYTE) then
		value = self:read8Byte(patchInfo)
	elseif(patchInfo.valueType == PatchInfo.TYPE.FLOAT) then
		value = self:readFloat(patchInfo)
	end
	return value
end

function ParamUtils:patchValue(patchInfo)
	if(patchInfo.valueType == PatchInfo.TYPE.BINARY) then
		self:writeBinary(patchInfo)
	elseif(patchInfo.valueType == PatchInfo.TYPE.BYTE) then
		self:writeByte(patchInfo)
	elseif(patchInfo.valueType == PatchInfo.TYPE.TWO_BYTE) then
		self:write2Byte(patchInfo)
	elseif(patchInfo.valueType == PatchInfo.TYPE.FOUR_BYTE) then
		self:write4Byte(patchInfo)
	elseif(patchInfo.valueType == PatchInfo.TYPE.EIGHT_BYTE) then
		self:write8Byte(patchInfo)
	elseif(patchInfo.valueType == PatchInfo.TYPE.FLOAT) then
		self:writeFloat(patchInfo)
	end
end

function ParamUtils:writeBinary(patchInfo)
	if(patchInfo.binaryOffset &gt; 0) then
		local prevValue = self:readByte(patchInfo)
		if(patchInfo.value == 0) then
			patchInfo.value = bAnd(prevValue, ~patchInfo.binaryOffset)
		else
			patchInfo.value = bOr(prevValue,patchInfo.binaryOffset)
		end
		writeBytes(patchInfo.address, patchInfo.value)
	else
		self:logError("To write a binary you've to set the 'binaryOffset'")
	end
end

function ParamUtils:writeByte(patchInfo)
	if(patchInfo.value &gt; 255) then
		self:logError("Byte can't be bigger then 255")
	elseif(patchInfo.value &lt; 0) then
		self:logError("Byte can't be smaller then 0")
	else
		writeBytes(patchInfo.address, patchInfo.value)
	end
end

function ParamUtils:write2Byte(patchInfo)
	if(patchInfo.value &gt; 65535) then
		self:logError("2 Bytes can't be bigger then 65535")
	elseif(patchInfo.value &lt; 0) then
		self:logError("2 Bytes can't be smaller then 0")
	else
		writeBytes(patchInfo.address, wordToByteTable(patchInfo.value))
	end
end

function ParamUtils:write4Byte(patchInfo)
	if(patchInfo.value &gt; 4294967295) then
		self:logError("4 Bytes can't be bigger then 4294967295")
	elseif(patchInfo.value &lt; -2147483648) then
		self:logError("4 Bytes can't be smaller then -2147483648")
	else
		writeInteger(patchInfo.address, patchInfo.value)
	end
end

function ParamUtils:write8Byte(patchInfo)
	if(patchInfo.value &gt; 9223372036854775807) then
		self:logError("8 Bytes can't be bigger then 9223372036854775807")
	elseif(patchInfo.value &lt; -9223372036854775808) then
		self:logError("8 Bytes can't be smaller then -9223372036854775808")
	else
		writeQword(patchInfo.address, patchInfo.value)
	end
end

function ParamUtils:writeFloat(patchInfo)
	if(patchInfo.value &gt; 3.4028235E38) then
		self:logError("Float can't be bigger then 3.4028235E38")
	elseif(patchInfo.value &lt; -3.4028235E38) then
		self:logError("Float can't be smaller then -3.4028235E38")
	else
		writeFloat(patchInfo.address, patchInfo.value)
	end
end

-- read functions
function ParamUtils:readByte(patchInfo)
	return readBytes(patchInfo.address, 1)
end

function ParamUtils:read2Byte(patchInfo)
	return byteTableToWord(readBytes(patchInfo.address, 2, true))
end

function ParamUtils:read4Byte(patchInfo)
	return readInteger(patchInfo.address)
end

function ParamUtils:read8Byte(patchInfo)
	return readQword(patchInfo.address)
end

function ParamUtils:readFloat(patchInfo)
	return readFloat(patchInfo.address)
end

function ParamUtils:printAllBackups()
  for uuid,tBackup in pairs(self.patchBackUp) do
	print("UUID: "..uuid)
	for i,object in ipairs(tBackup) do
	  print("Address: "..object.address.." Value: "..object.value.." Type: "..object.valueType)
	end
  end
end

-- Creating an instance of ParamUtils
paramUtils = ParamUtils:new()
--[[END ParamUtils class]]--

TestName = ""
-- Tests Part
function message(msg)
  showMessage(TestName.." Error: "..msg)
end

[DISABLE]
{$lua}
if syntaxcheck then return end
paramUtils:destroy()

</AssemblerScript>
      <CheatEntries>
        <CheatEntry>
          <ID>252</ID>
          <Description>"BaseParamClass"</Description>
          <Options moHideChildren="1"/>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
{$lua}
--if syntaxcheck then return end

--[[START BaseParamClass class]]--
BaseParamClass = {
	id = 0,
	param = "",
	backupUuid = "",
	address = 0
}

function BaseParamClass:new(param, uuid, id)
	local o = {}
	setmetatable(o, self)
	self.__index = self
	if(param ~= nil) then
		o.param = param
	end
	if(uuid ~= nil) then
		o.backupUuid = uuid
	end
	if(id ~= nil) then
		o.id = id
	end

	return o
end

function BaseParamClass:init()
  if(paramUtils.patchBackUp[self.backupUuid] == nil) then
    paramUtils.patchBackUp[self.backupUuid] = {}
  end
  self.address = paramUtils:getIdAddressFromParam(self.param, self.id)
end

-- Removes first Hex digit of the ID
function BaseParamClass:stripIdForParams(id)
	local idHex = paramUtils:toHex(id, 8)
	return tonumber(idHex:sub(2),16)
end

function BaseParamClass:stripSelfIdForParams()
	self.id = self:stripIdForParams(self.id)
end

--Patch all values
function BaseParamClass:patchAll(offset, value, valueType, binaryOffset)
	local addresses = paramUtils:getAllAddressFromParam(self.param)
	for i,address in ipairs(addresses) do
		local patchInfo = PatchInfo:new(address + offset, value, valueType, PatchInfo:getBinaryOffset(binaryOffset))
		paramUtils:patchValueWithBackup(patchInfo, self.backupUuid)
	end
end

function BaseParamClass:patchAllBinary(offset, value, binaryOffset)
	self:patchAll(offset, value, PatchInfo.TYPE.BINARY, binaryOffset)
end

function BaseParamClass:patchAllByte(offset, value)
	self:patchAll(offset, value, PatchInfo.TYPE.BYTE)
end

function BaseParamClass:patchAll2Byte(offset, value)
	self:patchAll(offset, value, PatchInfo.TYPE.TWO_BYTE)
end

function BaseParamClass:patchAll4Byte(offset, value)
	self:patchAll(offset, value, PatchInfo.TYPE.FOUR_BYTE)
end

function BaseParamClass:patchAll8Byte(offset, value)
	self:patchAll(offset, value, PatchInfo.TYPE.EIGHT_BYTE)
end

function BaseParamClass:patchAllFloat(offset, value)
	self:patchAll(offset, value, PatchInfo.TYPE.FLOAT)
end

-- Patch value
function BaseParamClass:patchValue(offset, value, valueType, binaryOffset)
	local patchInfo = PatchInfo:new(self.address + offset, value, valueType, PatchInfo:getBinaryOffset(binaryOffset))
	paramUtils:patchValueWithBackup(patchInfo, self.backupUuid)
end

function BaseParamClass:patchBinary(offset, value, binaryOffset)
	self:patchValue(offset, value, PatchInfo.TYPE.BINARY, binaryOffset)
end

function BaseParamClass:patchByte(offset, value)
	self:patchValue(offset, value, PatchInfo.TYPE.BYTE)
end

function BaseParamClass:patch2Byte(offset, value)
	self:patchValue(offset, value, PatchInfo.TYPE.TWO_BYTE)
end

function BaseParamClass:patch4Byte(offset, value)
	self:patchValue(offset, value, PatchInfo.TYPE.FOUR_BYTE)
end

function BaseParamClass:patch8Byte(offset, value)
	self:patchValue(offset, value, PatchInfo.TYPE.EIGHT_BYTE)
end

function BaseParamClass:patchFloat(offset, value)
	self:patchValue(offset, value, PatchInfo.TYPE.FLOAT)
end


--[[END BaseParamClass class]]--

[DISABLE]
{$lua}
--if syntaxcheck then return end

</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>251</ID>
              <Description>"EquipParamWeapon"</Description>
              <Options moHideChildren="1"/>
              <LastState/>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}
if syntaxcheck then return end

--[[START EquipParamWeapon class]]--
EquipParamWeapon = BaseParamClass:new()

function EquipParamWeapon:new(id, uuid)
	local o = {}
	setmetatable(o, self)
	self.__index = self
	o.param = "EquipParamWeapon"
	o.id = id
	o.backupUuid = uuid

	o:init()
    o:stripSelfIdForParams()
	return o
end

function EquipParamWeapon:behaviorId(value)
	self:patch4Byte(0x0, value)
end

function EquipParamWeapon:sortId(value)
	self:patch4Byte(0x4, value)
end

function EquipParamWeapon:wanderingEquipId(value)
	self:patch4Byte(0x8, value)
end

-- Weight
function EquipParamWeapon:weight(value)
	self:patchFloat(0xC, value)
end

function EquipParamWeapon:weaponWeightRate(value)
	self:patchFloat(0x10, value)
end

-- Prices
function EquipParamWeapon:fixPrice(value)
	self:patch4Byte(0x14, value)
end

function EquipParamWeapon:basicPrice(value)
	self:patch4Byte(0x18, value)
end

function EquipParamWeapon:sellValue(value)
	self:patch4Byte(0x1C, value)
end

-- Scaling
function EquipParamWeapon:correctStrength(value)
	self:patchFloat(0x20, value)
end

function EquipParamWeapon:correctAgility(value)
	self:patchFloat(0x24, value)
end

function EquipParamWeapon:correctMagic(value)
	self:patchFloat(0x28, value)
end

function EquipParamWeapon:correctFaith(value)
	self:patchFloat(0x2C, value)
end

--Block Rate
function EquipParamWeapon:physGuardCutRate(value)
	self:patchFloat(0x30, value)
end

function EquipParamWeapon:magGuardCutRate(value)
	self:patchFloat(0x34, value)
end

function EquipParamWeapon:fireGuardCutRate(value)
	self:patchFloat(0x38, value)
end

function EquipParamWeapon:thunGuardCutRate(value)
	self:patchFloat(0x3C, value)
end

-- Effects on hit
function EquipParamWeapon:spEffectBehaviorId(value)
	self:patch4Byte(0x40, value)
end

function EquipParamWeapon:spEffectBehaviorId1(value)
	self:patch4Byte(0x44, value)
end

function EquipParamWeapon:spEffectBehaviorId2(value)
	self:patch4Byte(0x48, value)
end

-- Effects on self
function EquipParamWeapon:residentSpEffectId(value)
	self:patch4Byte(0x4C, value)
end

function EquipParamWeapon:residentSpEffectId1(value)
	self:patch4Byte(0x50, value)
end

function EquipParamWeapon:residentSpEffectId2(value)
	self:patch4Byte(0x54, value)
end

function EquipParamWeapon:materialSetId(value)
	self:patch4Byte(0x58, value)
end

--Origin Equip Weapon
function EquipParamWeapon:originEquipWep(value)
	self:patch4Byte(0x5C, value)
end

function EquipParamWeapon:originEquipWep1(value)
	self:patch4Byte(0x60, value)
end

function EquipParamWeapon:originEquipWep2(value)
	self:patch4Byte(0x64, value)
end

function EquipParamWeapon:originEquipWep3(value)
	self:patch4Byte(0x68, value)
end

function EquipParamWeapon:originEquipWep4(value)
	self:patch4Byte(0x6C, value)
end

function EquipParamWeapon:originEquipWep5(value)
	self:patch4Byte(0x70, value)
end

function EquipParamWeapon:originEquipWep6(value)
	self:patch4Byte(0x74, value)
end

function EquipParamWeapon:originEquipWep7(value)
	self:patch4Byte(0x78, value)
end

function EquipParamWeapon:originEquipWep8(value)
	self:patch4Byte(0x7C, value)
end

function EquipParamWeapon:originEquipWep9(value)
	self:patch4Byte(0x80, value)
end

function EquipParamWeapon:originEquipWep10(value)
	self:patch4Byte(0x84, value)
end

function EquipParamWeapon:originEquipWep11(value)
	self:patch4Byte(0x88, value)
end

function EquipParamWeapon:originEquipWep12(value)
	self:patch4Byte(0x8C, value)
end

function EquipParamWeapon:originEquipWep13(value)
	self:patch4Byte(0x90, value)
end

function EquipParamWeapon:originEquipWep14(value)
	self:patch4Byte(0x94, value)
end

function EquipParamWeapon:originEquipWep15(value)
	self:patch4Byte(0x98, value)
end

--Anti Damage Rate
function EquipParamWeapon:antiDemonDamageRate(value)
	self:patchFloat(0x9C, value)
end

function EquipParamWeapon:antUndeadDamageRate(value)
	self:patchFloat(0xA0, value)
end

function EquipParamWeapon:antHollowDamageRate(value)
	self:patchFloat(0xA4, value)
end

function EquipParamWeapon:antAbyssalDamageRate(value)
	self:patchFloat(0xA8, value)
end

-- AC-BA
function EquipParamWeapon:vagrantItemLotId(value)
	self:patch4Byte(0xAC, value)
end

function EquipParamWeapon:vagrantBonusEneDropItemLotId(value)
	self:patch4Byte(0xB0, value)
end

function EquipParamWeapon:vagrantItemEneDropItemLotId(value)
	self:patch4Byte(0xB4, value)
end

function EquipParamWeapon:equipModelId(value)
	self:patch2Byte(0xB8, value)
end

function EquipParamWeapon:iconId(value)
	self:patch2Byte(0xBA, value)
end

-- Durability
function EquipParamWeapon:durability(value)
	self:patch2Byte(0xBC, value)
end

function EquipParamWeapon:durabilityMax(value)
	self:patch2Byte(0xBE, value)
end

-- C0-C2
function EquipParamWeapon:attackThrowEscape(value)
	self:patch2Byte(0xC0, value)
end

function EquipParamWeapon:parryDamageLife(value)
	self:patch2Byte(0xC2, value)
end

--Attack Damage
function EquipParamWeapon:attackBasePhysics(value)
	self:patch2Byte(0xC4, value)
end

function EquipParamWeapon:attackBaseMagic(value)
	self:patch2Byte(0xC6, value)
end

function EquipParamWeapon:attackBaseFire(value)
	self:patch2Byte(0xC8, value)
end

function EquipParamWeapon:attackBaseThunder(value)
	self:patch2Byte(0xCA, value)
end

function EquipParamWeapon:attackBaseStamina(value) -- Stamina consuption to block
	self:patch2Byte(0xCC, value)
end

-- CE-ED
function EquipParamWeapon:saWeaponDamage(value)
	self:patch2Byte(0xCE, value)
end

function EquipParamWeapon:saDurability(value)
	self:patch2Byte(0xD0, value)
end

function EquipParamWeapon:guardAngle(value)
	self:patch2Byte(0xD2, value)
end

function EquipParamWeapon:staminaGuardDef(value)
	self:patch2Byte(0xD4, value)
end

function EquipParamWeapon:reinforceTypeId(value)
	self:patch2Byte(0xD6, value)
end

function EquipParamWeapon:trophySGradeId(value)
	self:patch2Byte(0xD8, value)
end

function EquipParamWeapon:trophySeqId(value)
	self:patch2Byte(0xDA, value)
end

function EquipParamWeapon:throwAtkRate(value)
	self:patch2Byte(0xDC, value)
end

function EquipParamWeapon:bowDistRate(value)
	self:patch2Byte(0xDE, value)
end

function EquipParamWeapon:equipModelCategory(value)
	self:patchByte(0xE0, value)
end

function EquipParamWeapon:equipModelGender(value)
	self:patchByte(0xE1, value)
end

function EquipParamWeapon:weaponCategory(value)
	self:patchByte(0xE2, value)
end

function EquipParamWeapon:wepmotionCategory(value)
	self:patchByte(0xE3, value)
end

function EquipParamWeapon:guardmotionCategory(value)
	self:patchByte(0xE4, value)
end

function EquipParamWeapon:atkMaterial(value)
	self:patchByte(0xE5, value)
end

function EquipParamWeapon:defMaterial(value)
	self:patchByte(0xE6, value)
end

function EquipParamWeapon:defSfxMaterial(value)
	self:patchByte(0xE7, value)
end

function EquipParamWeapon:correctType(value)
	self:patchByte(0xE8, value)
end

function EquipParamWeapon:spAttribute(value)
	self:patchByte(0xE9, value)
end

function EquipParamWeapon:spAtkcategory(value)
	self:patchByte(0xEA, value)
end

--[[
function EquipParamWeapon:?(value)
	self:patchByte(0xEB, value)
end
]]--

function EquipParamWeapon:wepmotionOneHandId(value)
	self:patchByte(0xEC, value)
end

function EquipParamWeapon:wepmotionBothHandId(value)
	self:patchByte(0xEE, value)
end

-- Requirements
function EquipParamWeapon:properStrength(value)
	self:patchByte(0xEE, value)
end

function EquipParamWeapon:properAgility(value)
	self:patchByte(0xEF, value)
end

function EquipParamWeapon:properMagic(value)
	self:patchByte(0xF0, value)
end

function EquipParamWeapon:properFaith(value)
	self:patchByte(0xF1, value)
end

-- F2-100

function EquipParamWeapon:overStrength(value)
	self:patchByte(0xF2, value)
end

function EquipParamWeapon:attackBaseParry(value)
	self:patchByte(0xF3, value)
end

function EquipParamWeapon:defenseBaseParry(value)
	self:patchByte(0xF4, value)
end

function EquipParamWeapon:guardBaseRepel(value)
	self:patchByte(0xF5, value)
end

function EquipParamWeapon:attackBaseRepel(value)
	self:patchByte(0xF6, value)
end

function EquipParamWeapon:guardCutCancelRate(value)
	self:patchByte(0xF7, value)
end

function EquipParamWeapon:guardLevel(value)
	self:patchByte(0xF8, value)
end

function EquipParamWeapon:slashGuardCutRate(value)
	self:patchByte(0xF9, value)
end

function EquipParamWeapon:blowGuardCutRate(value)
	self:patchByte(0xFA, value)
end

function EquipParamWeapon:thrustGuardCutRate(value)
	self:patchByte(0xFB, value)
end

function EquipParamWeapon:poisonGuardResist(value)
	self:patchByte(0xFC, value)
end

function EquipParamWeapon:diseaseGuardResist(value)
	self:patchByte(0xFD, value)
end

function EquipParamWeapon:bloodGuardResist(value)
	self:patchByte(0xFE, value)
end

function EquipParamWeapon:curseGuardResist(value)
	self:patchByte(0xFF, value)
end

function EquipParamWeapon:isDurabilityDivergence(value)
	self:patchByte(0x100, value)
end

-- Flags
-- 101
function EquipParamWeapon:rightHandEquipable(value)
	self:patchBinary(0x101, value, 0)
end

function EquipParamWeapon:leftHandEquipable(value)
	self:patchBinary(0x101, value, 1)
end

function EquipParamWeapon:bothHandEquipable(value)
	self:patchBinary(0x101, value, 2)
end

function EquipParamWeapon:arrowSlotEquipable(value)
	self:patchBinary(0x101, value, 3)
end

function EquipParamWeapon:boltSlotEquipable(value)
	self:patchBinary(0x101, value, 4)
end

function EquipParamWeapon:enableGuard(value)
	self:patchBinary(0x101, value, 5)
end

function EquipParamWeapon:enableParry(value)
	self:patchBinary(0x101, value, 6)
end

function EquipParamWeapon:enableMagic(value)
	self:patchBinary(0x101, value, 7)
end

-- 102
function EquipParamWeapon:enablePyromancy(value)
	self:patchBinary(0x102, value, 0)
end

function EquipParamWeapon:enableMiracle(value)
	self:patchBinary(0x102, value, 1)
end

function EquipParamWeapon:enableVowMagic(value)
	self:patchBinary(0x102, value, 2)
end

function EquipParamWeapon:isNormalAttackType(value)
	self:patchBinary(0x102, value, 3)
end

function EquipParamWeapon:isBlowAttackType(value)
	self:patchBinary(0x102, value, 4)
end

function EquipParamWeapon:isSlashAttackType(value)
	self:patchBinary(0x102, value, 5)
end

function EquipParamWeapon:isThrustAttackType(value)
	self:patchBinary(0x102, value, 6)
end

function EquipParamWeapon:isEnhance(value)
	self:patchBinary(0x102, value, 7)
end

-- 103
function EquipParamWeapon:isLuckCorrect(value)
	self:patchBinary(0x103, value, 0)
end

function EquipParamWeapon:isCustom(value)
	self:patchBinary(0x103, value, 1)
end

function EquipParamWeapon:disableBaseChangeReset(value)
	self:patchBinary(0x103, value, 2)
end

function EquipParamWeapon:disableRepair(value)
	self:patchBinary(0x103, value, 3)
end

function EquipParamWeapon:isDarkHand(value)
	self:patchBinary(0x103, value, 4)
end

function EquipParamWeapon:simpleModelForDlc(value)
	self:patchBinary(0x103, value, 5)
end

function EquipParamWeapon:ubytelanternWep(value)
	self:patchBinary(0x103, value, 6)
end

function EquipParamWeapon:isVersusGhostWep(value)
	self:patchBinary(0x103, value, 7)
end

--Changes the infusion icon
function EquipParamWeapon:baseChangeCategory(value)
	self:patchBinary(0x104, value, 0)
end

function EquipParamWeapon:isDragonSlayer(value)
	self:patchBinary(0x104, value, 1)
end

function EquipParamWeapon:isDeposit(value)
	self:patchBinary(0x104, value, 2)
end

function EquipParamWeapon:disableMultiDropShare(value)
	self:patchBinary(0x104, value, 3)
end

-- insert Unknown 1 104 Binary 4 - 180 here

function EquipParamWeapon:darkGuardCutRate(value)
	self:patchFloat(0x184, value)
end

function EquipParamWeapon:attackBaseDark(value)
	self:patch2Byte(0x188, value)
end

-- insert Unknown 2 18A-193 here

function EquipParamWeapon:swordArt(value)
	self:patch4Byte(0x194, value)
end


function EquipParamWeapon:correctLuck(value)
	self:patchFloat(0x198, value)
end

function EquipParamWeapon:scalingCategories(value)
	self:patch4Byte(0x228, value)
end
-- insert Unknown 3 197-258 here

--[[END EquipParamWeapon class]]--

[DISABLE]
{$lua}
if syntaxcheck then return end

</AssemblerScript>
              <CheatEntries>
                <CheatEntry>
                  <ID>269</ID>
                  <Description>"EquipParamWeapon Tests"</Description>
                  <Options moHideChildren="1"/>
                  <LastState Value="" RealAddress="00000000"/>
                  <Color>C0C0C0</Color>
                  <GroupHeader>1</GroupHeader>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>270</ID>
                      <Description>"effectOnHit Test"</Description>
                      <LastState/>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>[ENABLE]
{$lua}
--if syntaxcheck then return end
local weapon = 0x001EAB90 --Long Sword
local equipWeapon = EquipParamWeapon:new(weapon,"effectOnHitTest")
equipWeapon:spEffectBehaviorId(10564)
equipWeapon:spEffectBehaviorId1(112079000)
equipWeapon:spEffectBehaviorId2(110)

[DISABLE]
{$lua}
--if syntaxcheck then return end

paramUtils:restore("effectOnHitTest")
</AssemblerScript>
                    </CheatEntry>
                    <CheatEntry>
                      <ID>271</ID>
                      <Description>"isEnhance Test"</Description>
                      <LastState/>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>[ENABLE]
{$lua}
--if syntaxcheck then return end
local weapon = 0x001EAB90 --Long Sword
local equipWeapon = EquipParamWeapon:new(weapon,"isEnhanceTest")
equipWeapon:isEnhance(0)

[DISABLE]
{$lua}
--if syntaxcheck then return end

paramUtils:restore("isEnhanceTest")
</AssemblerScript>
                    </CheatEntry>
                    <CheatEntry>
                      <ID>272</ID>
                      <Description>"Scaling Test"</Description>
                      <LastState/>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>[ENABLE]
{$lua}
--if syntaxcheck then return end
local weapon = 0x001EAB90 --Long Sword
local equipWeapon = EquipParamWeapon:new(weapon,"ScalingTest")
equipWeapon:correctStrength(100)
equipWeapon:correctAgility(100)
equipWeapon:correctMagic(100)
equipWeapon:correctFaith(100)

[DISABLE]
{$lua}
--if syntaxcheck then return end

paramUtils:restore("ScalingTest")
</AssemblerScript>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
                <CheatEntry>
                  <ID>489727</ID>
                  <Description>"Converted Scripts"</Description>
                  <Options moHideChildren="1"/>
                  <LastState Value="" RealAddress="00000000"/>
                  <GroupHeader>1</GroupHeader>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>489725</ID>
                      <Description>"Weapon Modification"</Description>
                      <LastState/>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>[ENABLE]
{$lua}
--if syntaxcheck then return end

local WeaponId = 0x4C4B40 -- Uchigatana

local equipWeapon = EquipParamWeapon:new(WeaponId,"weaponModificationTut")
-- Attack Damage
equipWeapon:attackBasePhysics(200) -- Physical Damage - 200
equipWeapon:attackBaseMagic(50)    -- Magic Damage - 50
equipWeapon:attackBaseFire(50)     -- Fire Damage - 50
equipWeapon:attackBaseThunder(50)  -- Lightning Damage - 50
equipWeapon:attackBaseDark(150)    -- Dark Damage - 150
-- Requirements
equipWeapon:properStrength(0)      -- Required STR - 0
equipWeapon:properAgility(0)       -- Required DEX - 0
equipWeapon:properMagic(0)         -- Required INT - 0
equipWeapon:properFaith(0)         -- Required FTH - 0
-- Scaling
equipWeapon:correctStrength(150)   -- STR Scaling - 150
equipWeapon:correctAgility(150)    -- DEX Scaling - 150
equipWeapon:correctMagic(50)       -- INT Scaling - 50
equipWeapon:correctFaith(50)       -- FTH Scaling - 50
-- Block
equipWeapon:physGuardCutRate(50)   -- Physical Block - 50
equipWeapon:magGuardCutRate(50)    -- Magic Block - 50
equipWeapon:fireGuardCutRate(50)   -- Fire Block - 50
equipWeapon:thunGuardCutRate(50)   -- Lightning Block - 50
equipWeapon:darkGuardCutRate(50)   -- Dark Block - 50
--Effects on Hit
equipWeapon:spEffectBehaviorId(3151) --Effect on Hit 1 -- Undead Hunter Charm
equipWeapon:spEffectBehaviorId1(110) --Effect on Hit 2 -- Bonfire
equipWeapon:spEffectBehaviorId2(2030)--Effect on Hit 2 -- Green Moss
--Effects on Self
equipWeapon:residentSpEffectId(112079000)  --Effect on Self 1 -- Pontiff's Left Eye effect
equipWeapon:residentSpEffectId1(112042000) --Effect on Self 2 -- Silvercat Ring effect
equipWeapon:residentSpEffectId2(112042000) --Effect on Self 2 -- Carthus Milkring

equipWeapon:saWeaponDamage(0)     -- Poise Damage - 100

equipWeapon:weight(0)             -- Weight - 0

[DISABLE]
{$lua}
--if syntaxcheck then return end
paramUtils:restore("weaponModificationTut")
</AssemblerScript>
                    </CheatEntry>
                    <CheatEntry>
                      <ID>489726</ID>
                      <Description>"Every Catalyst can cast everything"</Description>
                      <LastState/>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>{
	Author: Igromanru
	Description: Patch all catalyst to allow cast any sorcery, pyromancy and miracle
}
[ENABLE]
{$lua}
if not syntaxcheck then
  local catalysts = {13050000, 13260000, 13290000, 13270000, 13280000, 13300000, 13210000, 13220000, 13230000,
	13430000, 13240000, 13250000, 13140000, 13060000, 13170000, 13180000, 13190000, 13070000, 13080000, 13420000,
	13200000, 13110000, 13100000, 13440000, 13160000, 13400000, 13410000, 2160000, 4130000, 13120000, 8220000,
	10160000, 12070000
  }

  for i,id in ipairs(catalysts) do
	local weapon = EquipParamWeapon:new(id,"EveryCatalystCanCastEverything")
	weapon:enableMagic(1)
	weapon:enablePyromancy(1)
	weapon:enableMiracle(1)
  end
end

[DISABLE]
{$lua}
if not syntaxcheck then
  paramUtils:restore("EveryCatalystCanCastEverything")
end
</AssemblerScript>
                    </CheatEntry>
                    <CheatEntry>
                      <ID>489728</ID>
                      <Description>"Pyromancy Flame cast everything"</Description>
                      <LastState/>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>{
	Author: Igromanru
	Description: Patch Pyromancy Flame to allow cast any sorcery, pyromancy and miracle
}
[ENABLE]
{$lua}
if not syntaxcheck then
  local weapon = EquipParamWeapon:new(0xCC77C0,"PyromancyFlameCastEverything")
  weapon:enableMagic(1)
  weapon:enablePyromancy(1)
  weapon:enableMiracle(1)
end

[DISABLE]
{$lua}
if not syntaxcheck then
  paramUtils:restore("PyromancyFlameCastEverything")
end
</AssemblerScript>
                    </CheatEntry>
                    <CheatEntry>
                      <ID>1337011520</ID>
                      <Description>"Placing a red sign on weapon equip - Weapon Self Effect "</Description>
                      <LastState/>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>{
	Author: Igromanru
	Description: Place a red sign on equipping a Long Sword.
}
[ENABLE]
{$lua}
if not syntaxcheck then
  local WeaponId = 0x1EAB90 --Long Sword
  local weapon = EquipParamWeapon:new(WeaponId,"LongSwordPlaceRedSignOnEquip")
  weapon:residentSpEffectId(10)
end

[DISABLE]
{$lua}
if not syntaxcheck then
  paramUtils:restore("LongSwordPlaceRedSignOnEquip")
end
</AssemblerScript>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>278</ID>
              <Description>"EquipParamProtector"</Description>
              <Options moHideChildren="1"/>
              <LastState/>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}
if syntaxcheck then return end

--[[START EquipParamProtector class]]--
EquipParamProtector = BaseParamClass:new()

function EquipParamProtector:new(id, uuid)
	local o = {}
	setmetatable(o, self)
	self.__index = self
	o.param = "EquipParamProtector"
	o.id = id
	o.backupUuid = uuid

	o:init()
	o:stripSelfIdForParams()
	return o
end

function EquipParamProtector:sortId(value)
	self:patch4Byte(0x0, value)
end

function EquipParamProtector:wanderingEquipId(value)
	self:patch4Byte(0x4, value)
end

function EquipParamProtector:vagrantItemLotId(value)
	self:patch4Byte(0x8, value)
end

function EquipParamProtector:vagrantBonusEneDropItemLotId(value)
	self:patch4Byte(0xC, value)
end

function EquipParamProtector:vagrantItemEneDropItemLotId(value)
	self:patch4Byte(0x10, value)
end

--Prices
function EquipParamProtector:fixPrice(value)
	self:patch4Byte(0x14, value)
end

function EquipParamProtector:basicPrice(value)
	self:patch4Byte(0x18, value)
end

function EquipParamProtector:sellValue(value)
	self:patch4Byte(0x1C, value)
end

function EquipParamProtector:weight(value)
	self:patchFloat(0x20, value)
end

--Effect On Equip
function EquipParamProtector:residentSpEffectId(value)
	self:patch4Byte(0x24, value)
end

function EquipParamProtector:residentSpEffectId2(value)
	self:patch4Byte(0x28, value)
end

function EquipParamProtector:residentSpEffectId3(value)
	self:patch4Byte(0x2C, value)
end


function EquipParamProtector:materialSetId(value)
	self:patch4Byte(0x30, value)
end

function EquipParamProtector:partsDamageRate(value)
	self:patchFloat(0x34, value)
end

function EquipParamProtector:corectSARecover(value)
	self:patchFloat(0x38, value)
end

--Origin Equip Pros
function EquipParamProtector:originEquipPro(value)
	self:patch4Byte(0x3C, value)
end

function EquipParamProtector:originEquipPro1(value)
	self:patch4Byte(0x40, value)
end

function EquipParamProtector:originEquipPro2(value)
	self:patch4Byte(0x44, value)
end

function EquipParamProtector:originEquipPro3(value)
	self:patch4Byte(0x48, value)
end

function EquipParamProtector:originEquipPro4(value)
	self:patch4Byte(0x4C, value)
end

function EquipParamProtector:originEquipPro5(value)
	self:patch4Byte(0x50, value)
end

function EquipParamProtector:originEquipPro6(value)
	self:patch4Byte(0x54, value)
end

function EquipParamProtector:originEquipPro7(value)
	self:patch4Byte(0x58, value)
end

function EquipParamProtector:originEquipPro8(value)
	self:patch4Byte(0x5C, value)
end

function EquipParamProtector:originEquipPro9(value)
	self:patch4Byte(0x60, value)
end

function EquipParamProtector:originEquipPro10(value)
	self:patch4Byte(0x64, value)
end

function EquipParamProtector:originEquipPro11(value)
	self:patch4Byte(0x68, value)
end

function EquipParamProtector:originEquipPro12(value)
	self:patch4Byte(0x6C, value)
end

function EquipParamProtector:originEquipPro13(value)
	self:patch4Byte(0x70, value)
end

function EquipParamProtector:originEquipPro14(value)
	self:patch4Byte(0x74, value)
end

function EquipParamProtector:originEquipPro15(value)
	self:patch4Byte(0x78, value)
end


function EquipParamProtector:equipModelId(value)
	self:patch2Byte(0xA0, value)
end

function EquipParamProtector:iconIdM(value)
	self:patch2Byte(0xA2, value)
end

function EquipParamProtector:iconIdF(value)
	self:patch4Byte(0xA4, value)
end

function EquipParamProtector:knockbackBounceRate(value)
	self:patch2Byte(0xA8, value)
end

--Durability
function EquipParamProtector:durability(value)
	self:patch2Byte(0xAA, value)
end

function EquipParamProtector:durabilityMax(value)
	self:patch2Byte(0xAC, value)
end


function EquipParamProtector:saDurability(value)
	self:patch2Byte(0xAE, value)
end

--Resistence
function EquipParamProtector:resistPoison(value)
	self:patch2Byte(0xC0, value)
end

function EquipParamProtector:resistDisease(value)
	self:patch2Byte(0xC2, value)
end

function EquipParamProtector:resistBlood(value)
	self:patch2Byte(0xC4, value)
end

function EquipParamProtector:resistCurse(value)
	self:patchByte(0xC6, value)
end

--Defense
function EquipParamProtector:defensePhysical(value)
	self:patchFloat(0xE0, value)
end

function EquipParamProtector:defenseSlash(value)
	self:patchFloat(0xE4, value)
end

function EquipParamProtector:defenseStrike(value)
	self:patchFloat(0xE8, value)
end

function EquipParamProtector:defenseThrust(value)
	self:patchFloat(0xEC, value)
end

function EquipParamProtector:defenseMagic(value)
	self:patchFloat(0xF0, value)
end

function EquipParamProtector:defenseFire(value)
	self:patchFloat(0xE4, value)
end

function EquipParamProtector:defenseThunder(value)
	self:patchFloat(0xE8, value)
end


function EquipParamProtector:Poise(value)
	self:patchFloat(0x110, value)
end

function EquipParamProtector:defenseDark(value)
	self:patchFloat(0x118, value)
end

function EquipParamProtector:resistFrost(value)
	self:patch2Byte(0x12C, value)
end


--[[END EquipParamProtector class]]--

[DISABLE]
{$lua}
if syntaxcheck then return end

</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>293</ID>
              <Description>"EquipParamGoods"</Description>
              <Options moHideChildren="1"/>
              <LastState/>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}
if syntaxcheck then return end

--[[START EquipParamGoods class]]--
EquipParamGoods = BaseParamClass:new()

function EquipParamGoods:new(id, uuid)
	local o = {}
	setmetatable(o, self)
	self.__index = self
	o.param = "EquipParamGoods"
	o.id = id
	o.backupUuid = uuid

	o:init()
	o:stripSelfIdForParams()
	return o
end

function EquipParamGoods:refId(value)
	self:patch4Byte(0x0, value)
end

function EquipParamGoods:sfxVariationId(value)
	self:patch4Byte(0x4, value)
end

function EquipParamGoods:weight(value)
	self:patchFloat(0x8, value)
end

function EquipParamGoods:basicPrice(value)
	self:patch4Byte(0xC, value)
end

function EquipParamGoods:sellValue(value)
	self:patch4Byte(0x10, value)
end

function EquipParamGoods:behaviorId(value)
	self:patch4Byte(0x14, value)
end

function EquipParamGoods:replaceItemId(value)
	self:patch4Byte(0x18, value)
end

function EquipParamGoods:sortId(value)
	self:patch4Byte(0x1C, value)
end

function EquipParamGoods:qwcId(value)
	self:patch4Byte(0x20, value)
end

function EquipParamGoods:yesNoDialogMessageId(value)
	self:patch4Byte(0x24, value)
end

function EquipParamGoods:magicId(value)
	self:patch4Byte(0x28, value)
end

function EquipParamGoods:iconId(value)
	self:patch2Byte(0x2C, value)
end

function EquipParamGoods:modelId(value)
	self:patch2Byte(0x2E, value)
end

function EquipParamGoods:shopLv(value)
	self:patch2Byte(0x30, value)
end

function EquipParamGoods:compTrophySedId(value)
	self:patch2Byte(0x32, value)
end

function EquipParamGoods:trophySeqId(value)
	self:patch2Byte(0x34, value)
end

function EquipParamGoods:maxNum(value)
	self:patch2Byte(0x36, value)
end

function EquipParamGoods:consumeHeroPoint(value)
	self:patchByte(0x38, value)
end

function EquipParamGoods:overDexterity(value)
	self:patchByte(0x39, value)
end

function EquipParamGoods:goodsType(value)
	self:patchByte(0x3A, value)
end

function EquipParamGoods:refCategory(value)
	self:patchByte(0x3B, value)
end

function EquipParamGoods:goodsCategory(value)
	self:patchByte(0x3C, value)
end

function EquipParamGoods:goodsUseAnim(value)
	self:patchByte(0x3E, value)
end

function EquipParamGoods:opmeMenuType(value)
	self:patchByte(0x3F, value)
end

function EquipParamGoods:useLimitCategory(value)
	self:patchByte(0x40, value)
end

function EquipParamGoods:replaceCategory(value)
	self:patchByte(0x41, value)
end

--Vow Types
function EquipParamGoods:vowType0(value)
	self:patchBinary(0x42, value, 0)
end

function EquipParamGoods:vowType1(value)
	self:patchBinary(0x42, value, 1)
end

function EquipParamGoods:vowType2(value)
	self:patchBinary(0x42, value, 2)
end

function EquipParamGoods:vowType3(value)
	self:patchBinary(0x42, value, 3)
end

function EquipParamGoods:vowType4(value)
	self:patchBinary(0x42, value, 4)
end

function EquipParamGoods:vowType5(value)
	self:patchBinary(0x42, value, 5)
end

function EquipParamGoods:vowType6(value)
	self:patchBinary(0x42, value, 6)
end

function EquipParamGoods:vowType7(value)
	self:patchBinary(0x42, value, 7)
end

function EquipParamGoods:vowType8(value)
	self:patchBinary(0x43, value, 0)
end

function EquipParamGoods:vowType9(value)
	self:patchBinary(0x43, value, 1)
end

function EquipParamGoods:vowType10(value)
	self:patchBinary(0x43, value, 2)
end

function EquipParamGoods:vowType11(value)
	self:patchBinary(0x43, value, 3)
end

function EquipParamGoods:vowType12(value)
	self:patchBinary(0x43, value, 4)
end

function EquipParamGoods:vowType13(value)
	self:patchBinary(0x43, value, 5)
end

function EquipParamGoods:vowType14(value)
	self:patchBinary(0x43, value, 6)
end

function EquipParamGoods:vowType15(value)
	self:patchBinary(0x43, value, 7)
end

--Flags
function EquipParamGoods:enable_live(value)
	self:patchBinary(0x44, value, 0)
end

function EquipParamGoods:enable_gray(value)
	self:patchBinary(0x44, value, 1)
end

function EquipParamGoods:enable_white(value)
	self:patchBinary(0x44, value, 2)
end

function EquipParamGoods:enable_black(value)
	self:patchBinary(0x44, value, 3)
end

function EquipParamGoods:enable_multi(value)
	self:patchBinary(0x44, value, 4)
end

function EquipParamGoods:disable_offline(value)
	self:patchBinary(0x44, value, 5)
end

function EquipParamGoods:isEquip(value)
	self:patchBinary(0x44, value, 6)
end

function EquipParamGoods:isConsume(value)
	self:patchBinary(0x44, value, 7)
end

function EquipParamGoods:isAutoEquip(value)
	self:patchBinary(0x45, value, 0)
end

function EquipParamGoods:isEstablishment(value)
	self:patchBinary(0x45, value, 1)
end

function EquipParamGoods:isOnlyOne(value)
	self:patchBinary(0x45, value, 2)
end

function EquipParamGoods:isDrop(value)
	self:patchBinary(0x45, value, 3)
end

function EquipParamGoods:isDeposit(value)
	self:patchBinary(0x45, value, 4)
end

function EquipParamGoods:isDisableHand(value)
	self:patchBinary(0x45, value, 5)
end

function EquipParamGoods:IsTravelItem(value)
	self:patchBinary(0x45, value, 6)
end

function EquipParamGoods:isSuppleItem(value)
	self:patchBinary(0x45, value, 7)
end

function EquipParamGoods:isFullSuppleItem(value)
	self:patchBinary(0x46, value, 0)
end

function EquipParamGoods:isEnhance(value)
	self:patchBinary(0x46, value, 1)
end

function EquipParamGoods:isFixItem(value)
	self:patchBinary(0x46, value, 2)
end

function EquipParamGoods:disableMultiDropShare(value)
	self:patchBinary(0x46, value, 3)
end

function EquipParamGoods:disableUseAtColiseum(value)
	self:patchBinary(0x46, value, 4)
end

function EquipParamGoods:disableUseAtOutOfColiseum(value)
	self:patchBinary(0x46, value, 5)
end


function EquipParamGoods:vagrantItemLotId(value)
	self:patch4Byte(0x50, value)
end

function EquipParamGoods:vagrantBonusEneDropItemLotId(value)
	self:patch4Byte(0x54, value)
end

function EquipParamGoods:vagrantItemEneDropItemLotId(value)
	self:patch4Byte(0x58, value)
end

--[[END EquipParamGoods class]]--

[DISABLE]
{$lua}
if syntaxcheck then return end

</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>273</ID>
              <Description>"SpEffectParam"</Description>
              <Options moHideChildren="1"/>
              <LastState/>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}
if syntaxcheck then return end

--[[START SpEffectParam class]]--
SpEffectParam = BaseParamClass:new()

function SpEffectParam:new(id, uuid)
	local o = {}
	setmetatable(o, self)
	self.__index = self
	o.param = "SpEffectParam"
	o.id = id
	o.backupUuid = uuid

	o:init()
	return o
end

function SpEffectParam:iconId(value)
	self:patch4Byte(0x0, value)
end

function SpEffectParam:conditionHp(value)
	self:patchFloat(0x4, value)
end

function SpEffectParam:effectEndurance(value)
	self:patchFloat(0x8, value)
end

function SpEffectParam:motionInterval(value)
	self:patchFloat(0xC, value)
end

--Modifier
function SpEffectParam:maxHpRate(value)
	self:patchFloat(0x10, value)
end

function SpEffectParam:maxMpRate(value)
	self:patchFloat(0x14, value)
end

function SpEffectParam:maxStaminaRate(value)
	self:patchFloat(0x18, value)
end

--Damage Cut
function SpEffectParam:slashDamageCutRate(value)
	self:patchFloat(0x1C, value)
end

function SpEffectParam:blowDamageCutRate(value)
	self:patchFloat(0x20, value)
end

function SpEffectParam:thrustDamageCutRate(value)
	self:patchFloat(0x24, value)
end

function SpEffectParam:neutralDamageCutRate(value)
	self:patchFloat(0x28, value)
end

function SpEffectParam:magicDamageCutRate(value)
	self:patchFloat(0x2C, value)
end

function SpEffectParam:fireDamageCutRate(value)
	self:patchFloat(0x30, value)
end

function SpEffectParam:thunderDamageCutRate(value)
	self:patchFloat(0x34, value)
end

--Rate
function SpEffectParam:physicsAttackRate(value)
	self:patchFloat(0x38, value)
end

function SpEffectParam:magicAttackRate(value)
	self:patchFloat(0x3C, value)
end

function SpEffectParam:fireAttackRate(value)
	self:patchFloat(0x40, value)
end

function SpEffectParam:thunderAttackRate(value)
	self:patchFloat(0x44, value)
end

--Power Rate
function SpEffectParam:physicsAttackPowerRate(value)
	self:patchFloat(0x48, value)
end

function SpEffectParam:magicAttackPowerRate(value)
	self:patchFloat(0x4C, value)
end

function SpEffectParam:fireAttackPowerRate(value)
	self:patchFloat(0x50, value)
end

function SpEffectParam:thunderAttackPowerRate(value)
	self:patchFloat(0x54, value)
end

function SpEffectParam:physicsAttackPower(value)
	self:patch4Byte(0x58, value)
end

function SpEffectParam:magicAttackPower(value)
	self:patch4Byte(0x5C, value)
end

function SpEffectParam:fireAttackPower(value)
	self:patch4Byte(0x60, value)
end

function SpEffectParam:thunderAttackPower(value)
	self:patch4Byte(0x64, value)
end

--Diffence Rate
function SpEffectParam:physicsDiffenceRate(value)
	self:patchFloat(0x68, value)
end

function SpEffectParam:magicDiffenceRate(value)
	self:patchFloat(0x6C, value)
end

function SpEffectParam:fireDiffenceRate(value)
	self:patchFloat(0x70, value)
end

function SpEffectParam:thunderDiffenceRate(value)
	self:patchFloat(0x74, value)
end

function SpEffectParam:physicsDiffence(value)
	self:patch4Byte(0x78, value)
end

function SpEffectParam:magicDiffence(value)
	self:patch4Byte(0x7C, value)
end

function SpEffectParam:fireDiffence(value)
	self:patch4Byte(0x80, value)
end

function SpEffectParam:thunderDiffence(value)
	self:patch4Byte(0x84, value)
end

--Change Rare 1
function SpEffectParam:noGuardDamageRate(value)
	self:patchFloat(0x88, value)
end

function SpEffectParam:vitalSpotChangeRate(value)
	self:patchFloat(0x8C, value)
end

function SpEffectParam:normalSpotChangeRate(value)
	self:patchFloat(0x90, value)
end

function SpEffectParam:maxHpChangeRate(value)
	self:patchFloat(0x94, value)
end


function SpEffectParam:behaviorId(value)
	self:patch4Byte(0x98, value)
end

--Change Rare 2
function SpEffectParam:changeHpRate(value)
	self:patchFloat(0x9C, value)
end

function SpEffectParam:changeHpPoint(value)
	self:patch4Byte(0xA0, value)
end

function SpEffectParam:changeMpRate(value)
	self:patchFloat(0xA4, value)
end

function SpEffectParam:changeMpPoint(value)
	self:patch4Byte(0xA8, value)
end

function SpEffectParam:mpRecoverChangeSpeed(value)
	self:patch4Byte(0xAC, value)
end

function SpEffectParam:changeStaminaRate(value)
	self:patchFloat(0xB0, value)
end

function SpEffectParam:changeStaminaPoint(value)
	self:patch4Byte(0xB4, value)
end

function SpEffectParam:staminaRecoverChangeSpeed(value)
	self:patch4Byte(0xB8, value)
end


function SpEffectParam:magicEffectTimeChange(value)
	self:patchFloat(0xBC, value)
end

--Durability
function SpEffectParam:insideDurability(value)
	self:patch4Byte(0xC0, value)
end

function SpEffectParam:maxDurability(value)
	self:patch4Byte(0xC4, value)
end


function SpEffectParam:staminaAttackRate(value)
	self:patchFloat(0xC8, value)
end

function SpEffectParam:poizonAttackPower(value)
	self:patch4Byte(0xCC, value)
end

function SpEffectParam:registIllness(value)
	self:patch4Byte(0xD0, value)
end

function SpEffectParam:registBlood(value)
	self:patch4Byte(0xD4, value)
end

function SpEffectParam:registCurse(value)
	self:patch4Byte(0xD8, value)
end

function SpEffectParam:fallDamageRate(value)
	self:patchFloat(0xDC, value)
end

function SpEffectParam:soulRate(value)
	self:patchFloat(0xE0, value)
end

function SpEffectParam:equipWeightChangeRate(value)
	self:patchFloat(0xE4, value)
end

function SpEffectParam:allItemWeightChangeRate(value)
	self:patchFloat(0xE8, value)
end

function SpEffectParam:soul(value)
	self:patch4Byte(0xEC, value)
end

function SpEffectParam:animIdOffset(value)
	self:patch4Byte(0xF0, value)
end

function SpEffectParam:haveSoulRate(value)
	self:patchFloat(0xF4, value)
end

function SpEffectParam:targetPriority(value)
	self:patchFloat(0xF8, value)
end

function SpEffectParam:sightSearchEnemyCut(value)
	self:patch4Byte(0xFC, value)
end

function SpEffectParam:hearingSearchEnemyCut(value)
	self:patchFloat(0x100, value)
end

function SpEffectParam:grabityRate(value)
	self:patchFloat(0x104, value)
end

--Change Rate 3
function SpEffectParam:registPoizonChangeRate(value)
	self:patchFloat(0x108, value)
end

function SpEffectParam:registIllnessChangeRate(value)
	self:patchFloat(0x10C, value)
end

function SpEffectParam:registBloodChangeRate(value)
	self:patchFloat(0x110, value)
end

function SpEffectParam:registCurseChangeRate(value)
	self:patchFloat(0x114, value)
end


function SpEffectParam:soulStealRate(value)
	self:patchFloat(0x118, value)
end

function SpEffectParam:lifeReductionRate(value)
	self:patchFloat(0x11C, value)
end

function SpEffectParam:hpRecoverRate(value)
	self:patchFloat(0x120, value)
end

function SpEffectParam:replaceSpEffectId(value)
	self:patch4Byte(0x124, value)
end

function SpEffectParam:cycleOccurrenceSpEffectId(value)
	self:patch4Byte(0x128, value)
end

function SpEffectParam:atkOccurence(value)
	self:patch4Byte(0x12C, value)
end

function SpEffectParam:guardDefFlickPowerRate(value)
	self:patchFloat(0x130, value)
end

function SpEffectParam:guardStaminaCutRate(value)
	self:patchFloat(0x134, value)
end

function SpEffectParam:rayCastPassedTime(value)
	self:patch2Byte(0x138, value)
end

function SpEffectParam:changeSuperArmorPoint(value)
	self:patch2Byte(0x13A, value)
end

function SpEffectParam:bowDistRate(value)
	self:patch2Byte(0x13C, value)
end

function SpEffectParam:spCategory(value)
	self:patch2Byte(0x13E, value)
end

function SpEffectParam:categoryPriority(value)
	self:patchByte(0x140, value)
end

function SpEffectParam:saveCategory(value)
	self:patchByte(0x141, value)
end

function SpEffectParam:changeMagicSlot(value)
	self:patchByte(0x142, value)
end

function SpEffectParam:changeMiracleSlot(value)
	self:patchByte(0x143, value)
end

function SpEffectParam:heroPointDamage(value)
	self:patchByte(0x144, value)
end

function SpEffectParam:defFlickPower(value)
	self:patchByte(0x145, value)
end

function SpEffectParam:flickDamageCutRate(value)
	self:patchByte(0x146, value)
end

function SpEffectParam:bloodDamageRate(value)
	self:patchByte(0x147, value)
end

--Damage Level
function SpEffectParam:dmgLv_None(value)
	self:patchByte(0x148, value)
end

function SpEffectParam:dmgLv_S(value)
	self:patchByte(0x149, value)
end

function SpEffectParam:dmgLv_M(value)
	self:patchByte(0x14A, value)
end

function SpEffectParam:dmgLv_L(value)
	self:patchByte(0x14B, value)
end

function SpEffectParam:dmgLv_BlowM(value)
	self:patchByte(0x14C, value)
end

function SpEffectParam:dmgLv_Push(value)
	self:patchByte(0x14D, value)
end

function SpEffectParam:dmgLv_Strike(value)
	self:patchByte(0x14E, value)
end

function SpEffectParam:dmgLv_BlowS(value)
	self:patchByte(0x14F, value)
end

function SpEffectParam:dmgLv_Min(value)
	self:patchByte(0x150, value)
end

function SpEffectParam:dmgLv_Uppercut(value)
	self:patchByte(0x151, value)
end

function SpEffectParam:dmgLv_BlowLL(value)
	self:patchByte(0x152, value)
end

function SpEffectParam:dmgLv_Breath(value)
	self:patchByte(0x153, value)
end


function SpEffectParam:atkAttribute(value)
	self:patchByte(0x154, value)
end

function SpEffectParam:spAttribute(value)
	self:patchByte(0x155, value)
end

function SpEffectParam:stateInfo(value)
	self:patchByte(0x156, value)
end

function SpEffectParam:wepParamChange(value)
	self:patchByte(0x157, value)
end

function SpEffectParam:moveType(value)
	self:patchByte(0x158, value)
end

function SpEffectParam:lifeReductionType(value)
	self:patchByte(0x159, value)
end

function SpEffectParam:throwCondition(value)
	self:patchByte(0x15A, value)
end

function SpEffectParam:addBehaviorJudgeId_condition(value)
	self:patchByte(0x15B, value)
end

function SpEffectParam:addBehaviorJudgeId_add(value)
	self:patchByte(0x15C, value)
end

-- insert Minor 1 here

-- insert Unknown here

function SpEffectParam:frostAttackPower(value)
	self:patch4Byte(0x1AC, value)
end

function SpEffectParam:darkDamageCutRate(value)
	self:patchFloat(0x1D4, value)
end

function SpEffectParam:darkDifferenceRate(value)
	self:patchFloat(0x1D8, value)
end

function SpEffectParam:darkAttackPower(value)
	self:patch4Byte(0x1E4, value)
end

function SpEffectParam:registFrostChange(value)
	self:patch4Byte(0x2BC, value)
end

--Buff's
function SpEffectParam:VigorBuff(value)
	self:patchByte(0x308, value)
end

function SpEffectParam:AttunementBuff(value)
	self:patchByte(0x308, value)
end

function SpEffectParam:EnduranceBuff(value)
	self:patchByte(0x308, value)
end

function SpEffectParam:VitalityBuff(value)
	self:patchByte(0x308, value)
end

function SpEffectParam:StrenghtBuff(value)
	self:patchByte(0x308, value)
end

function SpEffectParam:DextrerityBuff(value)
	self:patchByte(0x308, value)
end

function SpEffectParam:IntelligenceBuff(value)
	self:patchByte(0x308, value)
end

function SpEffectParam:FaithBuff(value)
	self:patchByte(0x308, value)
end

function SpEffectParam:LuckBuff(value)
	self:patchByte(0x308, value)
end

--[[END SpEffectParam class]]--

[DISABLE]
{$lua}
if syntaxcheck then return end

</AssemblerScript>
              <CheatEntries>
                <CheatEntry>
                  <ID>1337011522</ID>
                  <Description>"Converted Scripts"</Description>
                  <Options moHideChildren="1"/>
                  <LastState Value="" RealAddress="00000000"/>
                  <GroupHeader>1</GroupHeader>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>1337011428</ID>
                      <Description>"Every Pine &amp; Bundle Infinite"</Description>
                      <LastState/>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>{
	Author: Igromanru
	Description: Makes Every Pine &amp; Bundle Infinite (cycle himself)
}
[ENABLE]
{$lua}
if not syntaxcheck then
  local catalysts = {2100,2110,2120,2130,2150,2170,2180,2190}

  for i,id in ipairs(catalysts) do
	local effect = SpEffectParam:new(id,"EveryPineAndBundleInfinite")
	effect:cycleOccurrenceSpEffectId(id)
  end
end

[DISABLE]
{$lua}
if not syntaxcheck then
  paramUtils:restore("EveryPineAndBundleInfinite")
end
</AssemblerScript>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>283</ID>
              <Description>"Magic"</Description>
              <Options moHideChildren="1"/>
              <LastState/>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}
if syntaxcheck then return end

--[[START Magic class]]--
Magic = BaseParamClass:new()

function Magic:new(id, uuid)
	local o = {}
	setmetatable(o, self)
	self.__index = self
	o.param = "Magic"
	o.id = id
	o.backupUuid = uuid

	o:init()
	o:stripSelfIdForParams()
	return o
end

function Magic:YesNoDialogBox(value)
	self:patchByte(0x0, value)
end

function Magic:LimitCancelSpEffectID(value)
	self:patch4Byte(0x4, value)
end

function Magic:SortID(value)
	self:patch2Byte(0x8, value)
end

function Magic:ReferenceID(value)
	self:patch2Byte(0xA, value)
end

function Magic:FPCost(value)
	self:patch2Byte(0xC, value)
end

function Magic:StaminaCost(value)
	self:patch2Byte(0xE, value)
end

function Magic:IconID(value)
	self:patch2Byte(0x10, value)
end

function Magic:BehaviorID(value)
	self:patch2Byte(0x12, value)
end

function Magic:MaterialItemID(value)
	self:patch2Byte(0x14, value)
end

function Magic:ReplaceMagicID(value)
	self:patch2Byte(0x16, value)
end

function Magic:NumberofCasts(value)
	self:patch2Byte(0x18, value)
end

function Magic:Humanity(value)
	self:patchByte(0x1A, value)
end

function Magic:OverDexterity(value)
	self:patchByte(0x1B, value)
end

function Magic:SFXVariation(value)
	self:patchByte(0x1C, value)
end

function Magic:SlotsUsed(value)
	self:patchByte(0x1D, value)
end

function Magic:RequiredINT(value)
	self:patchByte(0x1E, value)
end

function Magic:RequiredFAI(value)
	self:patchByte(0x1F, value)
end

function Magic:DexterityMinimumCastSpeedScaling(value)
	self:patchByte(0x20, value)
end

function Magic:DexterityMaximumCastSpeedScaling(value)
	self:patchByte(0x21, value)
end

function Magic:EzStateBehaviorType(value)
	self:patchByte(0x22, value)
end

function Magic:ReferenceCategory(value)
	self:patchByte(0x23, value)
end

function Magic:SpEffectCategory(value)
	self:patchByte(0x24, value)
end

function Magic:CastAnimation(value)
	self:patchByte(0x25, value)
end

function Magic:MenuType(value)
	self:patchByte(0x26, value)
end

function Magic:HasSpEffectType(value)
	self:patchByte(0x27, value)
end

function Magic:ReplaceCategory(value)
	self:patchByte(0x28, value)
end

function Magic:UseLimitCategory(value)
	self:patchByte(0x29, value)
end

-- insert Vow Types 1 here

function Magic:EnableMulti(value)
	self:patchBinary(0x2B, value, 0)
end

function Magic:EnableMultOnly(value)
	self:patchBinary(0x2B, value, 1)
end

function Magic:IsWeaponEnchant(value)
	self:patchBinary(0x2B, value, 2)
end

function Magic:IsShieldEnchant(value)
	self:patchBinary(0x2B, value, 3)
end

function Magic:EnableHuman(value)
	self:patchBinary(0x2B, value, 4)
end

function Magic:EnableDragonPhantom(value)
	self:patchBinary(0x2B, value, 5)
end

function Magic:EnableWhitePhantom(value)
	self:patchBinary(0x2B, value, 6)
end

function Magic:EnableBlackPhantom(value)
	self:patchBinary(0x2B, value, 7)
end

function Magic:DisableOffline(value)
	self:patchBinary(0x2C, value, 0)
end

function Magic:UsesMiracleResonance(value)
	self:patchBinary(0x2C, value, 1)
end

-- insert Vow Types 2 here

-- insert 2E-2F

function Magic:sfxID1(value)
	self:patch4Byte(0x30, value)
end

function Magic:sfxID2(value)
	self:patch4Byte(0x34, value)
end

function Magic:sfxID3(value)
	self:patch4Byte(0x38, value)
end

-- insert 3C-40

--Faith Breakpoints
function Magic:FaithBreakpoint20(value)
	self:patchByte(0x41, value)
end

function Magic:FaithBreakpoint30(value)
	self:patchByte(0x42, value)
end

function Magic:FaithBreakpoint40(value)
	self:patchByte(0x43, value)
end

function Magic:FaithBreakpoint60(value)
	self:patchByte(0x44, value)
end

-- insert 45-47


--Spell cast at X Faith
function Magic:Spellcastat20Faith(value)
	self:patch4Byte(0x48, value)
end

function Magic:Spellcastat20Faith(value)
	self:patch4Byte(0x4C, value)
end

function Magic:Spellcastat20Faith(value)
	self:patch4Byte(0x50, value)
end

function Magic:Spellcastat20Faith(value)
	self:patch4Byte(0x54, value)
end

-- insert 58-60

-- Bullets
function Magic:Bullet1(value)
	self:patch4Byte(0x64, value)
end

function Magic:Bullet2(value)
	self:patch4Byte(0x68, value)
end

function Magic:Bullet3(value)
	self:patch4Byte(0x6C, value)
end

-- insert 6C

function Magic:Bullet4(value)
	self:patch4Byte(0x70, value)
end

--[[END Magic class]]--

[DISABLE]
{$lua}
if syntaxcheck then return end

</AssemblerScript>
              <CheatEntries>
                <CheatEntry>
                  <ID>1337011521</ID>
                  <Description>"Converted Scripts"</Description>
                  <Options moHideChildren="1"/>
                  <LastState Value="" RealAddress="00000000"/>
                  <GroupHeader>1</GroupHeader>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>92124</ID>
                      <Description>"Remove FP and Stamina costs from Crystal Hail"</Description>
                      <LastState/>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>{
	Author: Igromanru
	Description: Removes FP and Stamina costs from the Crystal Hail
}
[ENABLE]
{$lua}
if not syntaxcheck then
  local magic = Magic:new(0x4014F348,"CrystalHailNoFPCost")
  magic:FPCost(0)
  magic:StaminaCost(0)
end

[DISABLE]
{$lua}
if not syntaxcheck then
  paramUtils:restore("CrystalHailNoFPCost")
end
</AssemblerScript>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>288</ID>
              <Description>"Bullet"</Description>
              <Options moHideChildren="1"/>
              <LastState/>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}
if syntaxcheck then return end

--[[START Bullet class]]--
Bullet = BaseParamClass:new()

function Bullet:new(id, uuid)
	local o = {}
	setmetatable(o, self)
	self.__index = self
	o.param = "Bullet"
	o.id = id
	o.backupUuid = uuid

	o:init()
	o:stripSelfIdForParams()
	return o
end

function Bullet:atkId_Bullet(value)
	self:patch4Byte(0x0, value)
end

function Bullet:sfxId_Bullet(value)
	self:patch4Byte(0x4, value)
end

function Bullet:sfxId_Hit(value)
	self:patch4Byte(0x8, value)
end

function Bullet:sfxId_Flick(value)
	self:patch4Byte(0xC, value)
end

function Bullet:life(value)
	self:patchFloat(0x10, value)
end

function Bullet:dist(value)
	self:patchFloat(0x14, value)
end

function Bullet:shootInterval(value)
	self:patchFloat(0x18, value)
end

function Bullet:gravityInRange(value)
	self:patch4Byte(0x1C, value)
end

function Bullet:gravityOutRange(value)
	self:patchFloat(0x20, value)
end

function Bullet:hormingStopRange(value)
	self:patchFloat(0x24, value)
end

function Bullet:initVellocity(value)
	self:patchFloat(0x28, value)
end

function Bullet:accelInRange(value)
	self:patchFloat(0x2C, value)
end

function Bullet:accelOutRange(value)
	self:patchFloat(0x30, value)
end

function Bullet:maxVellocity(value)
	self:patchFloat(0x34, value)
end

function Bullet:minVellocity(value)
	self:patchFloat(0x38, value)
end

function Bullet:accelTime(value)
	self:patchFloat(0x3C, value)
end

function Bullet:homingBeginDist(value)
	self:patchFloat(0x40, value)
end

function Bullet:hitRadius(value)
	self:patchFloat(0x44, value)
end

function Bullet:hitRadiusMax(value)
	self:patchFloat(0x48, value)
end

function Bullet:spreadTime(value)
	self:patchFloat(0x4C, value)
end

function Bullet:expDelay(value)
	self:patchFloat(0x50, value)
end

function Bullet:hormingOffsetRange(value)
	self:patchFloat(0x54, value)
end

function Bullet:dmgHitRecordLifeTime(value)
	self:patchFloat(0x58, value)
end

function Bullet:externalForce(value)
	self:patch4Byte(0x5C, value)
end

function Bullet:spEffectIDForShooter(value)
	self:patch4Byte(0x60, value)
end

function Bullet:autoSearchNPCThinkID(value)
	self:patch4Byte(0x64, value)
end

function Bullet:HitBulletID(value)
	self:patch4Byte(0x68, value)
end

--Special Effect IDs
function Bullet:spEffectId0(value)
	self:patch4Byte(0x7C, value)
end

function Bullet:spEffectId1(value)
	self:patch4Byte(0x70, value)
end

function Bullet:spEffectId2(value)
	self:patch4Byte(0x74, value)
end

function Bullet:spEffectId3(value)
	self:patch4Byte(0x78, value)
end

function Bullet:spEffectId4(value)
	self:patch4Byte(0x7C, value)
end

function Bullet:numShoot(value)
	self:patch2Byte(0x80, value)
end

function Bullet:homingAngle(value)
	self:patch2Byte(0x82, value)
end

function Bullet:shootAngle(value)
	self:patch2Byte(0x84, value)
end

function Bullet:shootAngleInterval(value)
	self:patch2Byte(0x86, value)
end

function Bullet:shootAngleXInterval(value)
	self:patch2Byte(0x88, value)
end

--Damp's
function Bullet:damageDamp(value)
	self:patchByte(0x8A, value)
end

function Bullet:spelDamageDamp(value)
	self:patchByte(0x8B, value)
end

function Bullet:fireDamageDamp(value)
	self:patchByte(0x8C, value)
end

function Bullet:thunderDamageDamp(value)
	self:patchByte(0x8D, value)
end

function Bullet:staminaDamp(value)
	self:patchByte(0x8E, value)
end

function Bullet:knockbackDamp(value)
	self:patchByte(0x8F, value)
end


function Bullet:shootAngleXZ(value)
	self:patchByte(0x90, value)
end

function Bullet:lockShootLimitAng(value)
	self:patchByte(0x91, value)
end

function Bullet:isPenetrate(value)
	self:patchByte(0x92, value)
end

function Bullet:prevVelocityDirRate(value)
	self:patchByte(0x93, value)
end

function Bullet:atkAttribute(value)
	self:patchByte(0x94, value)
end

function Bullet:spAttribute(value)
	self:patchByte(0x95, value)
end

function Bullet:Material_AttackType(value)
	self:patchByte(0x96, value)
end

function Bullet:Material_AttackMaterial(value)
	self:patchByte(0x97, value)
end

function Bullet:Material_Size(value)
	self:patchByte(0x99, value)
end

function Bullet:launchConditionType(value)
	self:patchByte(0x99, value)
end

--Falgs
function Magic:FollowType(value)
	self:patchBinary(0x9A, value, 0)
end

function Magic:EmittePosType(value)
	self:patchBinary(0x9A, value, 1)
end

function Magic:isAttackSFX(value)
	self:patchBinary(0x9A, value, 2)
end

function Magic:isEndlessHit(value)
	self:patchBinary(0x9A, value, 3)
end

function Magic:isPenetrateMap(value)
	self:patchBinary(0x9B, value, 0)
end

function Magic:isHitBothTeam(value)
	self:patchBinary(0x9B, value, 1)
end

function Magic:isUseSharedHitList(value)
	self:patchBinary(0x9B, value, 2)
end

function Magic:isUseMultiDmyPolyIfPlace(value)
	self:patchBinary(0x9B, value, 3)
end

function Magic:attachEffectType(value)
	self:patchBinary(0x9B, value, 4)
end

function Magic:isHitForceMagic(value)
	self:patchBinary(0x9B, value, 5)
end

function Magic:isIgnoreSfxIfHitWater(value)
	self:patchBinary(0x9B, value, 6)
end

function Magic:isIgnoreMoveStateIfHitWater(value)
	self:patchBinary(0x9B, value, 7)
end

function Magic:isHitDarkForceMagic(value)
	self:patchBinary(0x9C, value, 0)
end

-- insert Unknown binary flags 1-7 for 0x9C

--[[END Bullet class]]--

[DISABLE]
{$lua}
if syntaxcheck then return end

</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>253</ID>
          <Description>"ParamUtils Tests"</Description>
          <Options moHideChildren="1"/>
          <LastState Value="" RealAddress="00000000"/>
          <Color>C0C0C0</Color>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>256</ID>
              <Description>"PatchInfo Test"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}
TestName = "PatchInfo"

local object = PatchInfo:new(12345,1337,PatchInfo.TYPE.FOUR_BYTE)

if(object == nil) then
  message("PatchInfo object shouldn't be nil")
elseif(object.address ~= 12345) then
  message("'object.address' should be '12345'")
elseif(object.value ~= 1337) then
  message("'object.value' should be '1337'")
elseif(object.valueType ~= PatchInfo.TYPE.FOUR_BYTE) then
  message("'object.valueType' should be 'PatchInfo.TYPE.FOUR_BYTE'")
elseif(PatchInfo.TYPE.BINARY ~= 0) then
  message("'PatchInfo.TYPE.BINARY' should be '0'")
elseif(PatchInfo.TYPE.BYTE ~= 1) then
  message("'PatchInfo.TYPE.BYTE' should be '1'")
elseif(PatchInfo.TYPE.TWO_BYTE ~= 2) then
  message("'PatchInfo.TYPE.BYTE' should be '2'")
elseif(PatchInfo.TYPE.FOUR_BYTE ~= 3) then
  message("'PatchInfo.TYPE.BYTE' should be '3'")
elseif(PatchInfo.TYPE.EIGHT_BYTE ~= 4) then
  message("'PatchInfo.TYPE.BYTE' should be '4'")
elseif(PatchInfo.TYPE.FLOAT ~= 5) then
  message("'PatchInfo.TYPE.FLOAT' should be '5'")
end

[DISABLE]
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>257</ID>
              <Description>"getIdAddress Test"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}
TestName = memrec.Description

local idTable = {
	10,
	12,
	13,
	14
}

local id = paramUtils:getIdAddress(idTable, 2)

if(id ~= 12) then
  message("'id' should be '12'")
end


[DISABLE]

</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>258</ID>
              <Description>"readValue Tests"</Description>
              <Options moHideChildren="1"/>
              <LastState Value="" RealAddress="00000000"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>259</ID>
                  <Description>"ReadValue Byte Test"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
TestName = memrec.Description

local darkHand = 0xA87500
local address = paramUtils:getIdAddressFromParam("EquipParamWeapon",darkHand)
local offset = 0xE3 -- wepmotionCategory
local info = PatchInfo:new(address + offset, 0, PatchInfo.TYPE.BYTE)
local value = paramUtils:readValue(info)

if(type(value) ~= "number") then
  message("'value' should be a number")
elseif(value ~= 42) then
  message("'value' should be '42'")
end

[DISABLE]
{$lua}

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>260</ID>
                  <Description>"ReadValue 2 Byte Test"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
TestName = "ReadValue 2 Byte"

local darkHand = 0xA87500
local address = paramUtils:GetIdAddressFromParam("EquipParamWeapon",darkHand)
local offset = 0xCE -- saWeaponDamage
local info = PatchInfo:new(address + offset, 0, PatchInfo.TYPE.TWO_BYTE)
local value = paramUtils:ReadValue(info)

if(type(value) ~= "number") then
  message("'value' should be a number")
elseif(value ~= 14) then
  message("'value' should be '14'")
end

[DISABLE]
{$lua}

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>254</ID>
                  <Description>"ReadValue 4 Byte Test"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
TestName = "ReadValue 4 Byte"

local darkHand = 0xA87500
local address = paramUtils:GetIdAddressFromParam("EquipParamWeapon",darkHand)
local offset = 0x14 -- fixPrice
local info = PatchInfo:new(address + offset, 0, PatchInfo.TYPE.FOUR_BYTE)
local value = paramUtils:ReadValue(info)

if(type(value) ~= "number") then
  message("'value' should be a number")
elseif(value ~= 550) then
  message("'value' should be '550' integer")
end

[DISABLE]
{$lua}

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>262</ID>
                  <Description>"ReadValue 8 Byte Test"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
TestName = "ReadValue 8 Byte"

local darkHand = 0xA87500
local address = paramUtils:GetIdAddressFromParam("EquipParamWeapon",darkHand)
local offset = 0xC4 -- attackBasePhysics
local info = PatchInfo:new(address + offset, 0, PatchInfo.TYPE.EIGHT_BYTE)
local value = paramUtils:ReadValue(info)

if(type(value) ~= "number") then
  message("'value' should be a number")
elseif(value ~= 88) then
  message("'value' should be '88' integer")
end

[DISABLE]
{$lua}

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>261</ID>
                  <Description>"ReadValue Float Test"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
TestName = "ReadValue Float"

local darkHand = 0xA87500
local address = paramUtils:GetIdAddressFromParam("EquipParamWeapon",darkHand)
local offset = 0x30 -- Physical Block
local info = PatchInfo:new(address + offset, 0, PatchInfo.TYPE.FLOAT)
local value = paramUtils:ReadValue(info)

if(type(value) ~= "number") then
  message("'value' should be a number")
elseif(value ~= 65.0) then
  message("'value' should be '65.0' float")
end

[DISABLE]
{$lua}

</AssemblerScript>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>263</ID>
              <Description>"patchValue Tests"</Description>
              <Options moHideChildren="1"/>
              <LastState Value="" RealAddress="00000000"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>264</ID>
                  <Description>"PatchValue Byte Test"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
TestName = "PatchValue Byte"

local darkHand = 0xA87500
local address = paramUtils:GetIdAddressFromParam("EquipParamWeapon",darkHand)
local offset = 0xE3 -- wepmotionCategory
local info = PatchInfo:new(address + offset, 69, PatchInfo.TYPE.BYTE)

paramUtils:PatchValue(info)

local value = paramUtils:ReadValue(info)

if(type(value) ~= "number") then
  message("'value' should be a number")
elseif(value ~= 69) then
  message("'value' should be '69' but it's "..value)
end

[DISABLE]
{$lua}

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>265</ID>
                  <Description>"PatchValue 2 Byte Test"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
TestName = "PatchValue 2 Byte"

local darkHand = 0xA87500
local address = paramUtils:GetIdAddressFromParam("EquipParamWeapon",darkHand)
local offset = 0xCE -- saWeaponDamage
local info = PatchInfo:new(address + offset, 33, PatchInfo.TYPE.TWO_BYTE)

paramUtils:PatchValue(info)

local value = paramUtils:ReadValue(info)

if(type(value) ~= "number") then
  message("'value' should be a number")
elseif(value ~= 33) then
  message("'value' should be '33'")
end

[DISABLE]
{$lua}

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>266</ID>
                  <Description>"PatchValue 4 Byte Test"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
TestName = "PatchValue 4 Byte"

local darkHand = 0xA87500
local address = paramUtils:GetIdAddressFromParam("EquipParamWeapon",darkHand)
local offset = 0x14 -- fixPrice
local info = PatchInfo:new(address + offset, 1337, PatchInfo.TYPE.FOUR_BYTE)

paramUtils:PatchValue(info)

local value = paramUtils:ReadValue(info)

if(type(value) ~= "number") then
  message("'value' should be a number")
elseif(value ~= 1337) then
  message("'value' should be '1337' integer")
end

[DISABLE]
{$lua}

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>267</ID>
                  <Description>"PatchValue 8 Byte Test"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
TestName = "PatchValue 8 Byte"

local darkHand = 0xA87500
local address = paramUtils:GetIdAddressFromParam("EquipParamWeapon",darkHand)
local offset = 0xC4 -- attackBasePhysics
local info = PatchInfo:new(address + offset, 85423, PatchInfo.TYPE.EIGHT_BYTE)

paramUtils:PatchValue(info)

local value = paramUtils:ReadValue(info)

if(type(value) ~= "number") then
  message("'value' should be a number")
elseif(value ~= 85423) then
  message("'value' should be '85423' integer")
end

[DISABLE]
{$lua}

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>268</ID>
                  <Description>"PatchValue Float Test"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
TestName = "PatchValue Float"

local darkHand = 0xA87500
local address = paramUtils:GetIdAddressFromParam("EquipParamWeapon",darkHand)
local offset = 0x30 -- Physical Block
local info = PatchInfo:new(address + offset, 13.0, PatchInfo.TYPE.FLOAT)

paramUtils:PatchValue(info)

local value = paramUtils:ReadValue(info)

if(type(value) ~= "number") then
  message("'value' should be a number")
elseif(value ~= 13.0) then
  message("'value' should be '13.0' float bit it's "..value)
end

[DISABLE]
{$lua}

</AssemblerScript>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
  </CheatEntries>
  <CheatCodes>
    <CodeEntry>
      <Description>Gestures access :mov eax,[rcx]</Description>
      <Address>14081D330</Address>
      <ModuleName>DarkSoulsIII.exe</ModuleName>
      <ModuleNameOffset>81D330</ModuleNameOffset>
      <Before>
        <Byte>72</Byte>
        <Byte>C1</Byte>
        <Byte>FF</Byte>
        <Byte>CC</Byte>
        <Byte>8B</Byte>
      </Before>
      <Actual>
        <Byte>8B</Byte>
        <Byte>01</Byte>
      </Actual>
      <After>
        <Byte>89</Byte>
        <Byte>02</Byte>
        <Byte>48</Byte>
        <Byte>8B</Byte>
        <Byte>C2</Byte>
      </After>
    </CodeEntry>
    <CodeEntry>
      <Description>HP :mov [rbx+000000D8],eax</Description>
      <Address>140E94AA7</Address>
      <ModuleName>DarkSoulsIII.exe</ModuleName>
      <ModuleNameOffset>E94AA7</ModuleNameOffset>
      <Before>
        <Byte>C8</Byte>
        <Byte>CE</Byte>
        <Byte>04</Byte>
        <Byte>8B</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>89</Byte>
        <Byte>83</Byte>
        <Byte>D8</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>85</Byte>
        <Byte>C0</Byte>
        <Byte>55</Byte>
        <Byte>48</Byte>
        <Byte>BD</Byte>
      </After>
    </CodeEntry>
  </CheatCodes>
  <UserdefinedSymbols>
    <SymbolEntry>
      <Name>newmem2</Name>
      <Address>08DB0000</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>BonFireAOB</Name>
      <Address>140BE4F8B</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>BonFireAOBOriginal</Name>
      <Address>13FFF0000</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>messageRepoP</Name>
      <Address>140E1683C</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>projectile</Name>
      <Address>14063C6E4</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>projectile_ptr</Name>
      <Address>13FFF0022</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>AttackAddressToUse</Name>
      <Address>08DB0000</Address>
    </SymbolEntry>
  </UserdefinedSymbols>
  <Comments>Hotkeys:
Ctrl+N - toggle Noclip
	
</Comments>
</CheatTable>
