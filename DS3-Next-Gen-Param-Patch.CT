<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="26">
  <CheatEntries>
    <CheatEntry>
      <ID>249</ID>
      <Description>"ParamUtils"</Description>
      <Options moHideChildren="1"/>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
{$lua}
--if syntaxcheck then return end

--[[START PatchInfo class
	Author: Igromanru
	Description: Entity with informations (address, value and valueType).
					Also enum TYPE, with all possible value types.
]]--
PatchInfo = {
	address = 0,
	value = 0,
	valueType = 0,
	binaryOffset = 0,
	BINARYOFFSET = {
		ONE = 1,
		TWO = 2,
		THREE = 4,
		FOUR = 8,
		FIVE = 16,
		SIX = 32,
		SEVEN = 64,
		EIGHT = 128,
	},
	TYPE = {
		BINARY = 0,
		BYTE = 1,
		TWO_BYTE = 2,
		FOUR_BYTE = 3,
		EIGHT_BYTE = 4,
		FLOAT = 5,
	}
}

function PatchInfo:new(address, value, valueType, binaryOffset)
	local o = {}
	setmetatable(o, self)
	self.__index = self
	if(address ~= nil) then
		o.address = address
	end
	if(value ~= nil) then
		o.value = value
	end
	if(valueType ~= nil) then
		o.valueType = valueType
	end
	if(binaryOffset ~= nil) then
		o.binaryOffset = binaryOffset
	end

	return o
end

function PatchInfo:getBinaryOffset(value)
	local result = value
	if(value == 0) then
		result = PatchInfo.BINARYOFFSET.ONE
	elseif(value == 1) then
		result = PatchInfo.BINARYOFFSET.TWO
	elseif(value == 2) then
		result = PatchInfo.BINARYOFFSET.THREE
	elseif(value == 3) then
		result = PatchInfo.BINARYOFFSET.FOUR
	elseif(value == 4) then
		result = PatchInfo.BINARYOFFSET.FIVE
	elseif(value == 5) then
		result = PatchInfo.BINARYOFFSET.SIX
	elseif(value == 6) then
		result = PatchInfo.BINARYOFFSET.SEVEN
	elseif(value == 7) then
		result = PatchInfo.BINARYOFFSET.EIGHT
	end
	return result
end

--[[END PatchInfo class]]--

--[[START ParamUtils class
	Author: Igromanru
	Description: Utils class for Params
]]--
ParamUtils = {
	masterParamTable = {},
	patchBackUp = {},
    patchBackUpOld = {},
}

function ParamUtils:new()
	local function readIntegerSafe(Input)
		local Value = readInteger(Input)
		if Value &lt; 2147483647 then
			return Value
		else
			return Value - 0x100000000
		end
	end
	local function InitializeAddress()
		autoAssemble([[
			aobscanmodule(ParamPatchBase,DarkSoulsIII.exe,48 8B 0D ? ? ? ? 48 85 C9 74 0B 4C 8B C0 48 8B D7)
			registersymbol(ParamPatchBase)
		]])
		local addr = getAddress("ParamPatchBase")
		addr = addr + readIntegerSafe(addr + 0x3) + 7
		addr = readQword(addr)+ 0x10
		unregisterSymbol("ParamPatch")
		registerSymbol("ParamPatch", addr, true)
	end
	local o = {}
	setmetatable(o, self)
	self.__index = self

    InitializeAddress()
	o:paramIndexer()
	return o
end

function ParamUtils:destroy()
	unregisterSymbol("ParamPatchBase")
	unregisterSymbol("ParamPatch")
end

function ParamUtils:toHex(number, length)
	local result = ""
	if(length ~= nil and length &gt; 0) then
		result = string.format("%0"..length.."X",number)
	else
		result = string.format("%X",number)
	end
	return result
end

function ParamUtils:error(message)
	local output = "ParamUtils Error:\r\n"..message
	showMessage(output)
	error(output)
end

function ParamUtils:paramIndexer()
	local Param = getAddress("ParamPatch")
	local Start = readQword(Param)
	local End = readQword(Param+8)
	local Count = (End-Start)/8
	self.masterParamTable = {}

	for i = 0, Count - 1 do
	  local ParamOffset = readQword(Start+i*8)
	  local ParamString = "Unknown"
	  if readInteger(ParamOffset+0x20) &gt; 7 then
		 ParamString = readString(readQword(ParamOffset+0x10),90,true)
	  else
		 ParamString = readString(ParamOffset+0x10,90,true)
	  end
	  self.masterParamTable[ParamString] = ParamOffset
	end
end

function ParamUtils:getIdAddress(IdTable, Id)
	local result = IdTable[Id]
	if result == nil then
		self:error("ID:"..Id.." (hex:"..self:toHex(Id) ..") couldn't be found")
	end
	return result
end

function ParamUtils:getParamIdTable(ParamName)
	local IDTable = {}
	local ParamAddr = readQword(readQword(self.masterParamTable[ParamName]+0x68)+0x68)
	local TableCount = byteTableToWord(readBytes(ParamAddr+0xa,2,true))
	for i=0,TableCount-1 do
		local PID = readInteger(ParamAddr+0x40+0x18*i)
		local IDO = readInteger(ParamAddr+0x48+0x18*i)
		IDTable[PID] = ParamAddr + IDO
	end
	return IDTable
end

function ParamUtils:getIdAddressFromParam(paramName, id)
	local result = 0
	local idTable = self:getParamIdTable(paramName)

	if(idTable ~= nil) then
		result = self:getIdAddress(idTable, id)
	end
	return result
end

function ParamUtils:paramIterator(ParamName,ChangeTable,uuid)
	local IDTable = self:getParamIdTable(ParamName)
	if uuid ~= nil then --Make a table for backups
		if self.patchBackUpOld == nil then
			self.patchBackUpOld = {}
		end
		self.patchBackUpOld[uuid] = {}
		for k,v in pairs(ChangeTable) do
			local Backup = {}
			local _,DataLength = string.gsub(v[3], "%x+","")
			local idAddress = self:getIdAddress(IDTable,v[1])
			if idAddress ~= nil then
				Backup[1] = idAddress + v[2]
				Backup[2] = readBytes(Backup[1],DataLength,true)
				table.insert(self.patchBackUpOld[uuid],Backup)
				self:paramPatcher(idAddress,v[2],v[3],v[4])
			end
		end
	else
		for k,v in pairs(ChangeTable) do
			local idAddress = getIdAddress(IDTable,v[1])
			if idAddress ~= nil then
				self:paramPatcher(idAddress,v[2],v[3],v[4])
			end
		end
	end
end

function ParamUtils:paramPatcher(idAddress,DataOffset,Data,Symbol)
	local WriteAddr = idAddress+DataOffset
	local HexTable = {}
	if Symbol == nil then
		for word in string.gmatch(Data, "%x+") do table.insert(HexTable,tonumber(word,16)) end
		writeBytes(WriteAddr,HexTable)
	else
		registerSymbol(Symbol,WriteAddr,true)
	end
end

function ParamUtils:paramDepatcher(uuid)
	for k,v in pairs(self.patchBackUpOld[uuid]) do
		writeBytes(v[1],v[2])
	end
	self.patchBackUpOld[uuid] = nil
end

function ParamUtils:patchMultipleOffsets(paramName, id, patchInfoTable, uuid)
	if(self.patchBackUp[uuid] == nil) then
		local address = getIdAddressFromParam()
		for key,patchInfo in pairs(patchInfoTable) do
			patchInfo.address = address
			self:patchValueWithBackup(patchInfo,uuid)
		end
	else
        self:error("The UUID "..uuid.." is already in use.")
	end
end

function ParamUtils:restore(...)
	local arg = table.pack(...)
	for i,uuid in ipairs(arg) do
		for index,patchInfo in ipairs(self.patchBackUp[uuid]) do
			self:patchValue(patchInfo)
		end
		self.patchBackUp[uuid] = nil
	end
end

function ParamUtils:patchValueWithBackup(patchInfo, uuid)
	local readValue = self:readValue(patchInfo)
	local backup = true

	self:patchValue(patchInfo)

	for i,object in ipairs(self.patchBackUp[uuid]) do
		if(object.address == patchInfo.address) then
			backup = false
			break
		end
	end
	if(backup) then
		if(patchInfo.valueType == PatchInfo.TYPE.BINARY) then
			patchInfo.valueType = PatchInfo.TYPE.BYTE
		end
		table.insert(self.patchBackUp[uuid], PatchInfo:new(patchInfo.address, readValue, patchInfo.valueType))
	end
end

function ParamUtils:readValue(patchInfo)
	local value = 0
	if(patchInfo.valueType == PatchInfo.TYPE.BYTE or patchInfo.valueType == PatchInfo.TYPE.BINARY) then
		value = self:readByte(patchInfo)
	elseif(patchInfo.valueType == PatchInfo.TYPE.TWO_BYTE) then
		value = self:read2Byte(patchInfo)
	elseif(patchInfo.valueType == PatchInfo.TYPE.FOUR_BYTE) then
		value = self:read4Byte(patchInfo)
	elseif(patchInfo.valueType == PatchInfo.TYPE.EIGHT_BYTE) then
		value = self:read8Byte(patchInfo)
	elseif(patchInfo.valueType == PatchInfo.TYPE.FLOAT) then
		value = self:readFloat(patchInfo)
	end
	return value
end

function ParamUtils:patchValue(patchInfo)
	if(patchInfo.valueType == PatchInfo.TYPE.BINARY) then
		self:writeBinary(patchInfo)
	elseif(patchInfo.valueType == PatchInfo.TYPE.BYTE) then
		self:writeByte(patchInfo)
	elseif(patchInfo.valueType == PatchInfo.TYPE.TWO_BYTE) then
		self:write2Byte(patchInfo)
	elseif(patchInfo.valueType == PatchInfo.TYPE.FOUR_BYTE) then
		self:write4Byte(patchInfo)
	elseif(patchInfo.valueType == PatchInfo.TYPE.EIGHT_BYTE) then
		self:write8Byte(patchInfo)
	elseif(patchInfo.valueType == PatchInfo.TYPE.FLOAT) then
		self:writeFloat(patchInfo)
	end
end

function ParamUtils:writeBinary(patchInfo)
	if(patchInfo.binaryOffset &gt; 0) then
		local prevValue = self:readByte(patchInfo)
		if(patchInfo.value == 0) then
			patchInfo.value = bAnd(prevValue, ~patchInfo.binaryOffset)
		else
			patchInfo.value = bOr(prevValue,patchInfo.binaryOffset)
		end
		writeBytes(patchInfo.address, patchInfo.value)
	else
		self:error("To write a binary you've to set the 'binaryOffset'")
	end
end

function ParamUtils:writeByte(patchInfo)
	if(patchInfo.value &gt; 255) then
		self:error("Byte can't be bigger then 255")
	elseif(patchInfo.value &lt; 0) then
		self:error("Byte can't be smaller then 0")
	else
		writeBytes(patchInfo.address, patchInfo.value)
	end
end

function ParamUtils:write2Byte(patchInfo)
	if(patchInfo.value &gt; 65535) then
		self:error("2 Bytes can't be bigger then 65535")
	elseif(patchInfo.value &lt; 0) then
		self:error("2 Bytes can't be smaller then 0")
	else
		writeBytes(patchInfo.address, wordToByteTable(patchInfo.value))
	end
end

function ParamUtils:write4Byte(patchInfo)
	if(patchInfo.value &gt; 4294967295) then
		self:error("4 Bytes can't be bigger then 4294967295")
	elseif(patchInfo.value &lt; -2147483648) then
		self:error("4 Bytes can't be smaller then -2147483648")
	else
		writeInteger(patchInfo.address, patchInfo.value)
	end
end

function ParamUtils:write8Byte(patchInfo)
	if(patchInfo.value &gt; 9223372036854775807) then
		self:error("8 Bytes can't be bigger then 9223372036854775807")
	elseif(patchInfo.value &lt; -9223372036854775808) then
		self:error("8 Bytes can't be smaller then -9223372036854775808")
	else
		writeQword(patchInfo.address, patchInfo.value)
	end
end

function ParamUtils:writeFloat(patchInfo)
	if(patchInfo.value &gt; 3.4028235E38) then
		self:error("Float can't be bigger then 3.4028235E38")
	elseif(patchInfo.value &lt; -3.4028235E38) then
		self:error("Float can't be smaller then -3.4028235E38")
	else
		writeFloat(patchInfo.address, patchInfo.value)
	end
end

-- read functions
function ParamUtils:readByte(patchInfo)
	return readBytes(patchInfo.address, 1)
end

function ParamUtils:read2Byte(patchInfo)
	return byteTableToWord(readBytes(patchInfo.address, 2, true))
end

function ParamUtils:read4Byte(patchInfo)
	return readInteger(patchInfo.address)
end

function ParamUtils:read8Byte(patchInfo)
	return readQword(patchInfo.address)
end

function ParamUtils:readFloat(patchInfo)
	return readFloat(patchInfo.address)
end

-- Creating an instance of ParamUtils
paramUtils = ParamUtils:new()
--[[END ParamUtils class]]--

TestName = ""
-- Tests Part
function message(msg)
  showMessage(TestName.." Error: "..msg)
end

[DISABLE]
{$lua}
if syntaxcheck then return end
paramUtils:destroy()

</AssemblerScript>
      <CheatEntries>
        <CheatEntry>
          <ID>252</ID>
          <Description>"BaseParamClass"</Description>
          <Options moHideChildren="1"/>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
{$lua}
--if syntaxcheck then return end

--[[START BaseParamClass class]]--
BaseParamClass = {
	id = 0,
	param = "",
	backupUuid = "",
	address = 0
}

function BaseParamClass:new(o)
	o = o or {}
	setmetatable(o, self)
	self.__index = self

	return o
end

function BaseParamClass:init()
	paramUtils.patchBackUp[self.backupUuid] = {}
	self.address = paramUtils:getIdAddressFromParam(self.param, self.id)
end

function BaseParamClass:stripIdForParams()
	local idHex = paramUtils:toHex(self.id, 8)
	self.id = tonumber(idHex:sub(2),16)
end

function BaseParamClass:patchValue(offset, value, valueType, binaryOffset)
	local patchInfo = PatchInfo:new(self.address + offset, value, valueType, PatchInfo:getBinaryOffset(binaryOffset))
	paramUtils:patchValueWithBackup(patchInfo, self.backupUuid)
end

function BaseParamClass:patchBinary(offset, value, binaryOffset)
	self:patchValue(offset, value, PatchInfo.TYPE.BINARY, binaryOffset)
end

function BaseParamClass:patchByte(offset, value)
	self:patchValue(offset, value, PatchInfo.TYPE.BYTE)
end

function BaseParamClass:patch2Byte(offset, value)
	self:patchValue(offset, value, PatchInfo.TYPE.TWO_BYTE)
end

function BaseParamClass:patch4Byte(offset, value)
	self:patchValue(offset, value, PatchInfo.TYPE.FOUR_BYTE)
end

function BaseParamClass:patch8Byte(offset, value)
	self:patchValue(offset, value, PatchInfo.TYPE.EIGHT_BYTE)
end

function BaseParamClass:patchFloat(offset, value)
	self:patchValue(offset, value, PatchInfo.TYPE.FLOAT)
end


--[[END BaseParamClass class]]--

[DISABLE]
{$lua}
--if syntaxcheck then return end

</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>251</ID>
              <Description>"EquipParamWeapon"</Description>
              <Options moHideChildren="1"/>
              <LastState/>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}
if syntaxcheck then return end

--[[START EquipParamWeapon class]]--
EquipParamWeapon = BaseParamClass:new()

function EquipParamWeapon:new(id, uuid)
	local o = {}
	setmetatable(o, self)
	self.__index = self
	o.param = "EquipParamWeapon"
	o.id = id
	o.backupUuid = uuid

	o:init()
    o:stripIdForParams()
	return o
end

function EquipParamWeapon:behaviorId(value)
	self:patch4Byte(0x0, value)
end

function EquipParamWeapon:sortId(value)
	self:patch4Byte(0x4, value)
end

function EquipParamWeapon:wanderingEquipId(value)
	self:patch4Byte(0x8, value)
end

-- Weight
function EquipParamWeapon:weight(value)
	self:patchFloat(0xC, value)
end

function EquipParamWeapon:weaponWeightRate(value)
	self:patchFloat(0x10, value)
end

-- Prices
function EquipParamWeapon:fixPrice(value)
	self:patch4Byte(0x14, value)
end

function EquipParamWeapon:basicPrice(value)
	self:patch4Byte(0x18, value)
end

function EquipParamWeapon:sellValue(value)
	self:patch4Byte(0x1C, value)
end

-- Scaling
function EquipParamWeapon:correctStrength(value)
	self:patchFloat(0x20, value)
end

function EquipParamWeapon:correctAgility(value)
	self:patchFloat(0x24, value)
end

function EquipParamWeapon:correctMagic(value)
	self:patchFloat(0x28, value)
end

function EquipParamWeapon:correctFaith(value)
	self:patchFloat(0x2C, value)
end

--Block Rate
function EquipParamWeapon:physGuardCutRate(value)
	self:patchFloat(0x30, value)
end

function EquipParamWeapon:magGuardCutRate(value)
	self:patchFloat(0x34, value)
end

function EquipParamWeapon:fireGuardCutRate(value)
	self:patchFloat(0x38, value)
end

function EquipParamWeapon:thunGuardCutRate(value)
	self:patchFloat(0x3C, value)
end

-- Effects on hit
function EquipParamWeapon:effectOnHit1(value)
	self:patch4Byte(0x40, value)
end

function EquipParamWeapon:effectOnHit2(value)
	self:patch4Byte(0x44, value)
end

function EquipParamWeapon:effectOnHit3(value)
	self:patch4Byte(0x48, value)
end

-- Effects on self
function EquipParamWeapon:effectOnSelf1(value)
	self:patch4Byte(0x4C, value)
end

function EquipParamWeapon:effectOnSelf2(value)
	self:patch4Byte(0x50, value)
end

function EquipParamWeapon:effectOnSelf3(value)
	self:patch4Byte(0x54, value)
end

function EquipParamWeapon:materialSetId(value)
	self:patch4Byte(0x58, value)
end

--Origin Equip Weapon
function EquipParamWeapon:originEquipWep(value)
	self:patch4Byte(0x5C, value)
end

function EquipParamWeapon:originEquipWep1(value)
	self:patch4Byte(0x60, value)
end

function EquipParamWeapon:originEquipWep2(value)
	self:patch4Byte(0x64, value)
end

function EquipParamWeapon:originEquipWep3(value)
	self:patch4Byte(0x68, value)
end

function EquipParamWeapon:originEquipWep4(value)
	self:patch4Byte(0x6C, value)
end

function EquipParamWeapon:originEquipWep5(value)
	self:patch4Byte(0x70, value)
end

function EquipParamWeapon:originEquipWep6(value)
	self:patch4Byte(0x74, value)
end

function EquipParamWeapon:originEquipWep7(value)
	self:patch4Byte(0x78, value)
end

function EquipParamWeapon:originEquipWep8(value)
	self:patch4Byte(0x7C, value)
end

function EquipParamWeapon:originEquipWep9(value)
	self:patch4Byte(0x80, value)
end

function EquipParamWeapon:originEquipWep10(value)
	self:patch4Byte(0x84, value)
end

function EquipParamWeapon:originEquipWep11(value)
	self:patch4Byte(0x88, value)
end

function EquipParamWeapon:originEquipWep12(value)
	self:patch4Byte(0x8C, value)
end

function EquipParamWeapon:originEquipWep13(value)
	self:patch4Byte(0x90, value)
end

function EquipParamWeapon:originEquipWep14(value)
	self:patch4Byte(0x94, value)
end

function EquipParamWeapon:originEquipWep15(value)
	self:patch4Byte(0x98, value)
end

--Anti Damage Rate
function EquipParamWeapon:antiDemonDamageRate(value)
	self:patchFloat(0x9C, value)
end

function EquipParamWeapon:antUndeadDamageRate(value)
	self:patchFloat(0xA0, value)
end

function EquipParamWeapon:antHollowDamageRate(value)
	self:patchFloat(0xA4, value)
end

function EquipParamWeapon:antAbyssalDamageRate(value)
	self:patchFloat(0xA8, value)
end

-- AC-BA
function EquipParamWeapon:vagrantItemLotId(value)
	self:patch4Byte(0xAC, value)
end

function EquipParamWeapon:vagrantBonusEneDropItemLotId(value)
	self:patch4Byte(0xB0, value)
end

function EquipParamWeapon:vagrantItemEneDropItemLotId(value)
	self:patch4Byte(0xB4, value)
end

function EquipParamWeapon:equipModelId(value)
	self:patch2Byte(0xB8, value)
end

function EquipParamWeapon:iconId(value)
	self:patch2Byte(0xBA, value)
end

-- Durability
function EquipParamWeapon:durability(value)
	self:patch2Byte(0xBC, value)
end

function EquipParamWeapon:durabilityMax(value)
	self:patch2Byte(0xBE, value)
end

-- C0-C2
function EquipParamWeapon:attackThrowEscape(value)
	self:patch2Byte(0xC0, value)
end

function EquipParamWeapon:parryDamageLife(value)
	self:patch2Byte(0xC2, value)
end

--Attack Damage
function EquipParamWeapon:attackBaseMagic(value)
	self:patch2Byte(0xC6, value)
end

function EquipParamWeapon:attackBaseFire(value)
	self:patch2Byte(0xC8, value)
end

function EquipParamWeapon:attackBaseThunder(value)
	self:patch2Byte(0xCa, value)
end

function EquipParamWeapon:attackBaseStamina(value) -- Stamina consuption to block
	self:patch2Byte(0xCC, value)
end

-- CE-ED
function EquipParamWeapon:saWeaponDamage(value)
	self:patch2Byte(0xCE, value)
end

function EquipParamWeapon:saDurability(value)
	self:patch2Byte(0xD0, value)
end

function EquipParamWeapon:guardAngle(value)
	self:patch2Byte(0xD2, value)
end

function EquipParamWeapon:staminaGuardDef(value)
	self:patch2Byte(0xD4, value)
end

function EquipParamWeapon:reinforceTypeId(value)
	self:patch2Byte(0xD6, value)
end

function EquipParamWeapon:trophySGradeId(value)
	self:patch2Byte(0xD8, value)
end

function EquipParamWeapon:trophySeqId(value)
	self:patch2Byte(0xDA, value)
end

function EquipParamWeapon:throwAtkRate(value)
	self:patch2Byte(0xDC, value)
end

function EquipParamWeapon:bowDistRate(value)
	self:patch2Byte(0xDE, value)
end

function EquipParamWeapon:equipModelCategory(value)
	self:patchByte(0xE0, value)
end

function EquipParamWeapon:equipModelGender(value)
	self:patchByte(0xE1, value)
end

function EquipParamWeapon:weaponCategory(value)
	self:patchByte(0xE2, value)
end

function EquipParamWeapon:wepmotionCategory(value)
	self:patchByte(0xE3, value)
end

function EquipParamWeapon:guardmotionCategory(value)
	self:patchByte(0xE4, value)
end

function EquipParamWeapon:atkMaterial(value)
	self:patchByte(0xE5, value)
end

function EquipParamWeapon:defMaterial(value)
	self:patchByte(0xE6, value)
end

function EquipParamWeapon:defSfxMaterial(value)
	self:patchByte(0xE7, value)
end

function EquipParamWeapon:correctType(value)
	self:patchByte(0xE8, value)
end

function EquipParamWeapon:spAttribute(value)
	self:patchByte(0xE9, value)
end

function EquipParamWeapon:spAtkcategory(value)
	self:patchByte(0xEA, value)
end

--[[
function EquipParamWeapon:?(value)
	self:patchByte(0xEB, value)
end
]]--

function EquipParamWeapon:wepmotionOneHandId(value)
	self:patchByte(0xEC, value)
end

function EquipParamWeapon:wepmotionBothHandId(value)
	self:patchByte(0xEE, value)
end

-- Requirements
function EquipParamWeapon:properStrength(value)
	self:patchByte(0xEE, value)
end

function EquipParamWeapon:properAgility(value)
	self:patchByte(0xEF, value)
end

function EquipParamWeapon:properMagic(value)
	self:patchByte(0xF0, value)
end

function EquipParamWeapon:properFaith(value)
	self:patchByte(0xF1, value)
end

-- F2-100

function EquipParamWeapon:overStrength(value)
	self:patchByte(0xF2, value)
end

function EquipParamWeapon:attackBaseParry(value)
	self:patchByte(0xF3, value)
end

function EquipParamWeapon:defenseBaseParry(value)
	self:patchByte(0xF4, value)
end

function EquipParamWeapon:guardBaseRepel(value)
	self:patchByte(0xF5, value)
end

function EquipParamWeapon:attackBaseRepel(value)
	self:patchByte(0xF6, value)
end

function EquipParamWeapon:guardCutCancelRate(value)
	self:patchByte(0xF7, value)
end

function EquipParamWeapon:guardLevel(value)
	self:patchByte(0xF8, value)
end

function EquipParamWeapon:slashGuardCutRate(value)
	self:patchByte(0xF9, value)
end

function EquipParamWeapon:blowGuardCutRate(value)
	self:patchByte(0xFA, value)
end

function EquipParamWeapon:thrustGuardCutRate(value)
	self:patchByte(0xFB, value)
end

function EquipParamWeapon:poisonGuardResist(value)
	self:patchByte(0xFC, value)
end

function EquipParamWeapon:diseaseGuardResist(value)
	self:patchByte(0xFD, value)
end

function EquipParamWeapon:bloodGuardResist(value)
	self:patchByte(0xFE, value)
end

function EquipParamWeapon:curseGuardResist(value)
	self:patchByte(0xFF, value)
end

function EquipParamWeapon:isDurabilityDivergence(value)
	self:patchByte(0x100, value)
end

-- Flags
-- 101
function EquipParamWeapon:rightHandEquipable(value)
	self:patchBinary(0x101, value, 0)
end

function EquipParamWeapon:leftHandEquipable(value)
	self:patchBinary(0x101, value, 1)
end

function EquipParamWeapon:bothHandEquipable(value)
	self:patchBinary(0x101, value, 2)
end

function EquipParamWeapon:arrowSlotEquipable(value)
	self:patchBinary(0x101, value, 3)
end

function EquipParamWeapon:boltSlotEquipable(value)
	self:patchBinary(0x101, value, 4)
end

function EquipParamWeapon:enableGuard(value)
	self:patchBinary(0x101, value, 5)
end

function EquipParamWeapon:enableParry(value)
	self:patchBinary(0x101, value, 6)
end

function EquipParamWeapon:enableMagic(value)
	self:patchBinary(0x101, value, 7)
end

-- 102
function EquipParamWeapon:enablePyromancy(value)
	self:patchBinary(0x102, value, 0)
end

function EquipParamWeapon:enableMiracle(value)
	self:patchBinary(0x102, value, 1)
end

function EquipParamWeapon:enableVowMagic(value)
	self:patchBinary(0x102, value, 2)
end

function EquipParamWeapon:isNormalAttackType(value)
	self:patchBinary(0x102, value, 3)
end

function EquipParamWeapon:isBlowAttackType(value)
	self:patchBinary(0x102, value, 4)
end

function EquipParamWeapon:isSlashAttackType(value)
	self:patchBinary(0x102, value, 5)
end

function EquipParamWeapon:isThrustAttackType(value)
	self:patchBinary(0x102, value, 6)
end

function EquipParamWeapon:isEnhance(value)
	self:patchBinary(0x102, value, 7)
end

-- 103
function EquipParamWeapon:isLuckCorrect(value)
	self:patchBinary(0x103, value, 0)
end

function EquipParamWeapon:isCustom(value)
	self:patchBinary(0x103, value, 1)
end

function EquipParamWeapon:disableBaseChangeReset(value)
	self:patchBinary(0x103, value, 2)
end

function EquipParamWeapon:disableRepair(value)
	self:patchBinary(0x103, value, 3)
end

function EquipParamWeapon:isDarkHand(value)
	self:patchBinary(0x103, value, 4)
end

function EquipParamWeapon:simpleModelForDlc(value)
	self:patchBinary(0x103, value, 5)
end

function EquipParamWeapon:ubytelanternWep(value)
	self:patchBinary(0x103, value, 6)
end

function EquipParamWeapon:isVersusGhostWep(value)
	self:patchBinary(0x103, value, 7)
end

--Changes the infusion icon
function EquipParamWeapon:baseChangeCategory(value)
	self:patchBinary(0x104, value, 0)
end

function EquipParamWeapon:isDragonSlayer(value)
	self:patchBinary(0x104, value, 1)
end

function EquipParamWeapon:isDeposit(value)
	self:patchBinary(0x104, value, 2)
end

function EquipParamWeapon:disableMultiDropShare(value)
	self:patchBinary(0x104, value, 3)
end

-- insert Unknown 1 104 Binary 4 - 180 here

function EquipParamWeapon:darkGuardCutRate(value)
	self:patchFloat(0x184, value)
end

function EquipParamWeapon:attackBaseDark(value)
	self:patch2Byte(0x188, value)
end

-- insert Unknown 2 18A-193 here

function EquipParamWeapon:swordArt(value)
	self:patch4Byte(0x194, value)
end

-- insert Unknown 3 197-258 here

--[[END EquipParamWeapon class]]--

[DISABLE]
{$lua}
if syntaxcheck then return end

</AssemblerScript>
              <CheatEntries>
                <CheatEntry>
                  <ID>269</ID>
                  <Description>"EquipParamWeapon Tests"</Description>
                  <Options moHideChildren="1"/>
                  <LastState Value="" RealAddress="00000000"/>
                  <Color>C0C0C0</Color>
                  <GroupHeader>1</GroupHeader>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>270</ID>
                      <Description>"effectOnHit Test"</Description>
                      <LastState/>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>[ENABLE]
{$lua}
--if syntaxcheck then return end
local weapon = 0x001EAB90 --Long Sword
local equipWeapon = EquipParamWeapon:new(weapon,"effectOnHitTest")
equipWeapon:effectOnHit1(10564)
equipWeapon:effectOnHit2(112079000)
equipWeapon:effectOnHit3(110)

[DISABLE]
{$lua}
--if syntaxcheck then return end

paramUtils:restore("effectOnHitTest")
</AssemblerScript>
                    </CheatEntry>
                    <CheatEntry>
                      <ID>271</ID>
                      <Description>"isEnhance Test"</Description>
                      <LastState/>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>[ENABLE]
{$lua}
--if syntaxcheck then return end
local weapon = 0x001EAB90 --Long Sword
local equipWeapon = EquipParamWeapon:new(weapon,"isEnhanceTest")
equipWeapon:isEnhance(0)

[DISABLE]
{$lua}
--if syntaxcheck then return end

paramUtils:restore("isEnhanceTest")
</AssemblerScript>
                    </CheatEntry>
                    <CheatEntry>
                      <ID>272</ID>
                      <Description>"Scaling Test"</Description>
                      <LastState/>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>[ENABLE]
{$lua}
--if syntaxcheck then return end
local weapon = 0x001EAB90 --Long Sword
local equipWeapon = EquipParamWeapon:new(weapon,"ScalingTest")
equipWeapon:correctStrength(100)
equipWeapon:correctAgility(100)
equipWeapon:correctMagic(100)
equipWeapon:correctFaith(100)

[DISABLE]
{$lua}
--if syntaxcheck then return end

paramUtils:restore("ScalingTest")
</AssemblerScript>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>278</ID>
              <Description>"EquipParamProtector"</Description>
              <Options moHideChildren="1"/>
              <LastState/>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}
if syntaxcheck then return end

--[[START EquipParamProtector class]]--
EquipParamProtector = BaseParamClass:new()

function EquipParamProtector:new(id, uuid)
	local o = {}
	setmetatable(o, self)
	self.__index = self
	o.param = "EquipParamProtector"
	o.id = id
	o.backupUuid = uuid

	o:init()
	o:stripIdForParams()
	return o
end

function EquipParamProtector:sortId(value)
	self:patch4Byte(0x0, value)
end

function EquipParamProtector:wanderingEquipId(value)
	self:patch4Byte(0x4, value)
end

function EquipParamProtector:vagrantItemLotId(value)
	self:patch4Byte(0x8, value)
end

function EquipParamProtector:vagrantBonusEneDropItemLotId(value)
	self:patch4Byte(0xC, value)
end

function EquipParamProtector:vagrantItemEneDropItemLotId(value)
	self:patch4Byte(0x10, value)
end

--Prices
function EquipParamProtector:fixPrice(value)
	self:patch4Byte(0x14, value)
end

function EquipParamProtector:basicPrice(value)
	self:patch4Byte(0x18, value)
end

function EquipParamProtector:sellValue(value)
	self:patch4Byte(0x1C, value)
end

function EquipParamProtector:weight(value)
	self:patchFloat(0x20, value)
end

--Effect On Equip
function EquipParamProtector:residentSpEffectId(value)
	self:patch4Byte(0x24, value)
end

function EquipParamProtector:residentSpEffectId2(value)
	self:patch4Byte(0x28, value)
end

function EquipParamProtector:residentSpEffectId3(value)
	self:patch4Byte(0x2C, value)
end


function EquipParamProtector:materialSetId(value)
	self:patch4Byte(0x30, value)
end

function EquipParamProtector:partsDamageRate(value)
	self:patchFloat(0x34, value)
end

function EquipParamProtector:corectSARecover(value)
	self:patchFloat(0x38, value)
end

--Origin Equip Pros
function EquipParamProtector:originEquipPro(value)
	self:patch4Byte(0x3C, value)
end

function EquipParamProtector:originEquipPro1(value)
	self:patch4Byte(0x40, value)
end

function EquipParamProtector:originEquipPro2(value)
	self:patch4Byte(0x44, value)
end

function EquipParamProtector:originEquipPro3(value)
	self:patch4Byte(0x48, value)
end

function EquipParamProtector:originEquipPro4(value)
	self:patch4Byte(0x4C, value)
end

function EquipParamProtector:originEquipPro5(value)
	self:patch4Byte(0x50, value)
end

function EquipParamProtector:originEquipPro6(value)
	self:patch4Byte(0x54, value)
end

function EquipParamProtector:originEquipPro7(value)
	self:patch4Byte(0x58, value)
end

function EquipParamProtector:originEquipPro8(value)
	self:patch4Byte(0x5C, value)
end

function EquipParamProtector:originEquipPro9(value)
	self:patch4Byte(0x60, value)
end

function EquipParamProtector:originEquipPro10(value)
	self:patch4Byte(0x64, value)
end

function EquipParamProtector:originEquipPro11(value)
	self:patch4Byte(0x68, value)
end

function EquipParamProtector:originEquipPro12(value)
	self:patch4Byte(0x6C, value)
end

function EquipParamProtector:originEquipPro13(value)
	self:patch4Byte(0x70, value)
end

function EquipParamProtector:originEquipPro14(value)
	self:patch4Byte(0x74, value)
end

function EquipParamProtector:originEquipPro15(value)
	self:patch4Byte(0x78, value)
end


function EquipParamProtector:equipModelId(value)
	self:patch2Byte(0xA0, value)
end

function EquipParamProtector:iconIdM(value)
	self:patch2Byte(0xA2, value)
end

function EquipParamProtector:iconIdF(value)
	self:patch4Byte(0xA4, value)
end

function EquipParamProtector:knockbackBounceRate(value)
	self:patch2Byte(0xA8, value)
end

--Durability
function EquipParamProtector:durability(value)
	self:patch2Byte(0xAA, value)
end

function EquipParamProtector:durabilityMax(value)
	self:patch2Byte(0xAC, value)
end


function EquipParamProtector:saDurability(value)
	self:patch2Byte(0xAE, value)
end

--Resistence
function EquipParamProtector:resistPoison(value)
	self:patch2Byte(0xC0, value)
end

function EquipParamProtector:resistDisease(value)
	self:patch2Byte(0xC2, value)
end

function EquipParamProtector:resistBlood(value)
	self:patch2Byte(0xC4, value)
end

function EquipParamProtector:resistCurse(value)
	self:patchByte(0xC6, value)
end

--Defense
function EquipParamProtector:defensePhysical(value)
	self:patchFloat(0xE0, value)
end

function EquipParamProtector:defenseSlash(value)
	self:patchFloat(0xE4, value)
end

function EquipParamProtector:defenseStrike(value)
	self:patchFloat(0xE8, value)
end

function EquipParamProtector:defenseThrust(value)
	self:patchFloat(0xEC, value)
end

function EquipParamProtector:defenseMagic(value)
	self:patchFloat(0xF0, value)
end

function EquipParamProtector:defenseFire(value)
	self:patchFloat(0xE4, value)
end

function EquipParamProtector:defenseThunder(value)
	self:patchFloat(0xE8, value)
end


function EquipParamProtector:Poise(value)
	self:patchFloat(0x110, value)
end

function EquipParamProtector:defenseDark(value)
	self:patchFloat(0x118, value)
end

function EquipParamProtector:resistFrost(value)
	self:patch2Byte(0x12C, value)
end


--[[END EquipParamProtector class]]--

[DISABLE]
{$lua}
if syntaxcheck then return end

</AssemblerScript>
              <CheatEntries>
                <CheatEntry>
                  <ID>279</ID>
                  <Description>"EquipParamWeapon Tests"</Description>
                  <Options moHideChildren="1"/>
                  <LastState Value="" RealAddress="00000000"/>
                  <Color>C0C0C0</Color>
                  <GroupHeader>1</GroupHeader>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>280</ID>
                      <Description>"effectOnHit Test"</Description>
                      <LastState/>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>[ENABLE]
{$lua}
--if syntaxcheck then return end
local weapon = 0x001EAB90 --Long Sword
local equipWeapon = EquipParamWeapon:new(weapon,"effectOnHitTest")
equipWeapon:effectOnHit1(10564)
equipWeapon:effectOnHit2(112079000)
equipWeapon:effectOnHit3(110)

[DISABLE]
{$lua}
--if syntaxcheck then return end

paramUtils:restore("effectOnHitTest")
</AssemblerScript>
                    </CheatEntry>
                    <CheatEntry>
                      <ID>281</ID>
                      <Description>"isEnhance Test"</Description>
                      <LastState/>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>[ENABLE]
{$lua}
--if syntaxcheck then return end
local weapon = 0x001EAB90 --Long Sword
local equipWeapon = EquipParamWeapon:new(weapon,"isEnhanceTest")
equipWeapon:isEnhance(0)

[DISABLE]
{$lua}
--if syntaxcheck then return end

paramUtils:restore("isEnhanceTest")
</AssemblerScript>
                    </CheatEntry>
                    <CheatEntry>
                      <ID>282</ID>
                      <Description>"Scaling Test"</Description>
                      <LastState/>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>[ENABLE]
{$lua}
--if syntaxcheck then return end
local weapon = 0x001EAB90 --Long Sword
local equipWeapon = EquipParamWeapon:new(weapon,"ScalingTest")
equipWeapon:correctStrength(100)
equipWeapon:correctAgility(100)
equipWeapon:correctMagic(100)
equipWeapon:correctFaith(100)

[DISABLE]
{$lua}
--if syntaxcheck then return end

paramUtils:restore("ScalingTest")
</AssemblerScript>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>293</ID>
              <Description>"EquipParamGoods"</Description>
              <Options moHideChildren="1"/>
              <LastState/>
              <Color>008000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}
if syntaxcheck then return end

--[[START EquipParamGoods class]]--
EquipParamGoods = BaseParamClass:new()

function EquipParamGoods:new(id, uuid)
	local o = {}
	setmetatable(o, self)
	self.__index = self
	o.param = "EquipParamGoods"
	o.id = id
	o.backupUuid = uuid

	o:init()
	o:stripIdForParams()
	return o
end

function EquipParamGoods:refId(value)
	self:patch4Byte(0x0, value)
end

function EquipParamGoods:sfxVariationId(value)
	self:patch4Byte(0x4, value)
end

function EquipParamGoods:weight(value)
	self:patchFloat(0x8, value)
end

function EquipParamGoods:basicPrice(value)
	self:patch4Byte(0xC, value)
end

function EquipParamGoods:sellValue(value)
	self:patch4Byte(0x10, value)
end

function EquipParamGoods:behaviorId(value)
	self:patch4Byte(0x14, value)
end

function EquipParamGoods:replaceItemId(value)
	self:patch4Byte(0x18, value)
end

function EquipParamGoods:sortId(value)
	self:patch4Byte(0x1C, value)
end

function EquipParamGoods:qwcId(value)
	self:patch4Byte(0x20, value)
end

function EquipParamGoods:yesNoDialogMessageId(value)
	self:patch4Byte(0x24, value)
end

function EquipParamGoods:magicId(value)
	self:patch4Byte(0x28, value)
end

function EquipParamGoods:iconId(value)
	self:patch2Byte(0x2C, value)
end

function EquipParamGoods:modelId(value)
	self:patch2Byte(0x2E, value)
end

function EquipParamGoods:shopLv(value)
	self:patch2Byte(0x30, value)
end

function EquipParamGoods:compTrophySedId(value)
	self:patch2Byte(0x32, value)
end

function EquipParamGoods:trophySeqId(value)
	self:patch2Byte(0x34, value)
end

function EquipParamGoods:maxNum(value)
	self:patch2Byte(0x36, value)
end

function EquipParamGoods:consumeHeroPoint(value)
	self:patchByte(0x38, value)
end

function EquipParamGoods:overDexterity(value)
	self:patchByte(0x39, value)
end

function EquipParamGoods:goodsType(value)
	self:patchByte(0x3A, value)
end

function EquipParamGoods:refCategory(value)
	self:patchByte(0x3B, value)
end

function EquipParamGoods:goodsCategory(value)
	self:patchByte(0x3C, value)
end

function EquipParamGoods:goodsUseAnim(value)
	self:patchByte(0x3E, value)
end

function EquipParamGoods:opmeMenuType(value)
	self:patchByte(0x3F, value)
end

function EquipParamGoods:useLimitCategory(value)
	self:patchByte(0x40, value)
end

function EquipParamGoods:replaceCategory(value)
	self:patchByte(0x41, value)
end

--Vow Types
function EquipParamGoods:vowType0(value)
	self:patchBinary(0x42, value, 0)
end

function EquipParamGoods:vowType1(value)
	self:patchBinary(0x42, value, 1)
end

function EquipParamGoods:vowType2(value)
	self:patchBinary(0x42, value, 2)
end

function EquipParamGoods:vowType3(value)
	self:patchBinary(0x42, value, 3)
end

function EquipParamGoods:vowType4(value)
	self:patchBinary(0x42, value, 4)
end

function EquipParamGoods:vowType5(value)
	self:patchBinary(0x42, value, 5)
end

function EquipParamGoods:vowType6(value)
	self:patchBinary(0x42, value, 6)
end

function EquipParamGoods:vowType7(value)
	self:patchBinary(0x42, value, 7)
end

function EquipParamGoods:vowType8(value)
	self:patchBinary(0x43, value, 0)
end

function EquipParamGoods:vowType9(value)
	self:patchBinary(0x43, value, 1)
end

function EquipParamGoods:vowType10(value)
	self:patchBinary(0x43, value, 2)
end

function EquipParamGoods:vowType11(value)
	self:patchBinary(0x43, value, 3)
end

function EquipParamGoods:vowType12(value)
	self:patchBinary(0x43, value, 4)
end

function EquipParamGoods:vowType13(value)
	self:patchBinary(0x43, value, 5)
end

function EquipParamGoods:vowType14(value)
	self:patchBinary(0x43, value, 6)
end

function EquipParamGoods:vowType15(value)
	self:patchBinary(0x43, value, 7)
end

--Flags
function EquipParamGoods:enable_live(value)
	self:patchBinary(0x44, value, 0)
end

function EquipParamGoods:enable_gray(value)
	self:patchBinary(0x44, value, 1)
end

function EquipParamGoods:enable_white(value)
	self:patchBinary(0x44, value, 2)
end

function EquipParamGoods:enable_black(value)
	self:patchBinary(0x44, value, 3)
end

function EquipParamGoods:enable_multi(value)
	self:patchBinary(0x44, value, 4)
end

function EquipParamGoods:disable_offline(value)
	self:patchBinary(0x44, value, 5)
end

function EquipParamGoods:isEquip(value)
	self:patchBinary(0x44, value, 6)
end

function EquipParamGoods:isConsume(value)
	self:patchBinary(0x44, value, 7)
end

function EquipParamGoods:isAutoEquip(value)
	self:patchBinary(0x45, value, 0)
end

function EquipParamGoods:isEstablishment(value)
	self:patchBinary(0x45, value, 1)
end

function EquipParamGoods:isOnlyOne(value)
	self:patchBinary(0x45, value, 2)
end

function EquipParamGoods:isDrop(value)
	self:patchBinary(0x45, value, 3)
end

function EquipParamGoods:isDeposit(value)
	self:patchBinary(0x45, value, 4)
end

function EquipParamGoods:isDisableHand(value)
	self:patchBinary(0x45, value, 5)
end

function EquipParamGoods:IsTravelItem(value)
	self:patchBinary(0x45, value, 6)
end

function EquipParamGoods:isSuppleItem(value)
	self:patchBinary(0x45, value, 7)
end

function EquipParamGoods:isFullSuppleItem(value)
	self:patchBinary(0x46, value, 0)
end

function EquipParamGoods:isEnhance(value)
	self:patchBinary(0x46, value, 1)
end

function EquipParamGoods:isFixItem(value)
	self:patchBinary(0x46, value, 2)
end

function EquipParamGoods:disableMultiDropShare(value)
	self:patchBinary(0x46, value, 3)
end

function EquipParamGoods:disableUseAtColiseum(value)
	self:patchBinary(0x46, value, 4)
end

function EquipParamGoods:disableUseAtOutOfColiseum(value)
	self:patchBinary(0x46, value, 5)
end


function EquipParamGoods:vagrantItemLotId(value)
	self:patch4Byte(0x50, value)
end

function EquipParamGoods:vagrantBonusEneDropItemLotId(value)
	self:patch4Byte(0x54, value)
end

function EquipParamGoods:vagrantItemEneDropItemLotId(value)
	self:patch4Byte(0x58, value)
end

--[[END EquipParamGoods class]]--

[DISABLE]
{$lua}
if syntaxcheck then return end

</AssemblerScript>
              <CheatEntries>
                <CheatEntry>
                  <ID>294</ID>
                  <Description>"EquipParamWeapon Tests"</Description>
                  <Options moHideChildren="1"/>
                  <LastState Value="" RealAddress="00000000"/>
                  <Color>C0C0C0</Color>
                  <GroupHeader>1</GroupHeader>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>295</ID>
                      <Description>"effectOnHit Test"</Description>
                      <LastState/>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>[ENABLE]
{$lua}
--if syntaxcheck then return end
local weapon = 0x001EAB90 --Long Sword
local equipWeapon = EquipParamWeapon:new(weapon,"effectOnHitTest")
equipWeapon:effectOnHit1(10564)
equipWeapon:effectOnHit2(112079000)
equipWeapon:effectOnHit3(110)

[DISABLE]
{$lua}
--if syntaxcheck then return end

paramUtils:restore("effectOnHitTest")
</AssemblerScript>
                    </CheatEntry>
                    <CheatEntry>
                      <ID>296</ID>
                      <Description>"isEnhance Test"</Description>
                      <LastState/>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>[ENABLE]
{$lua}
--if syntaxcheck then return end
local weapon = 0x001EAB90 --Long Sword
local equipWeapon = EquipParamWeapon:new(weapon,"isEnhanceTest")
equipWeapon:isEnhance(0)

[DISABLE]
{$lua}
--if syntaxcheck then return end

paramUtils:restore("isEnhanceTest")
</AssemblerScript>
                    </CheatEntry>
                    <CheatEntry>
                      <ID>297</ID>
                      <Description>"Scaling Test"</Description>
                      <LastState/>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>[ENABLE]
{$lua}
--if syntaxcheck then return end
local weapon = 0x001EAB90 --Long Sword
local equipWeapon = EquipParamWeapon:new(weapon,"ScalingTest")
equipWeapon:correctStrength(100)
equipWeapon:correctAgility(100)
equipWeapon:correctMagic(100)
equipWeapon:correctFaith(100)

[DISABLE]
{$lua}
--if syntaxcheck then return end

paramUtils:restore("ScalingTest")
</AssemblerScript>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>273</ID>
              <Description>"SpEffectParam"</Description>
              <Options moHideChildren="1"/>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}
if syntaxcheck then return end

--[[START SpEffectParam class]]--
SpEffectParam = BaseParamClass:new()

function SpEffectParam:new(id, uuid)
	local o = {}
	setmetatable(o, self)
	self.__index = self
	o.param = "SpEffectParam"
	o.id = id
	o.backupUuid = uuid

	o:init()
	return o
end

function SpEffectParam:iconId(value)
	self:patch4Byte(0x0, value)
end

function SpEffectParam:conditionHp(value)
	self:patchFloat(0x4, value)
end

function SpEffectParam:effectEndurance(value)
	self:patchFloat(0x8, value)
end

function SpEffectParam:motionInterval(value)
	self:patchFloat(0xC, value)
end

--Modifier
function SpEffectParam:maxHpRate(value)
	self:patchFloat(0x10, value)
end

function SpEffectParam:maxMpRate(value)
	self:patchFloat(0x14, value)
end

function SpEffectParam:maxStaminaRate(value)
	self:patchFloat(0x18, value)
end

--Damage Cut


--[[END SpEffectParam class]]--

[DISABLE]
{$lua}
if syntaxcheck then return end

</AssemblerScript>
              <CheatEntries>
                <CheatEntry>
                  <ID>274</ID>
                  <Description>"EquipParamWeapon Tests"</Description>
                  <Options moHideChildren="1"/>
                  <LastState Value="" RealAddress="00000000"/>
                  <Color>C0C0C0</Color>
                  <GroupHeader>1</GroupHeader>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>275</ID>
                      <Description>"effectOnHit Test"</Description>
                      <LastState/>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>[ENABLE]
{$lua}
--if syntaxcheck then return end
local weapon = 0x001EAB90 --Long Sword
local equipWeapon = EquipParamWeapon:new(weapon,"effectOnHitTest")
equipWeapon:effectOnHit1(10564)
equipWeapon:effectOnHit2(112079000)
equipWeapon:effectOnHit3(110)

[DISABLE]
{$lua}
--if syntaxcheck then return end

paramUtils:restore("effectOnHitTest")
</AssemblerScript>
                    </CheatEntry>
                    <CheatEntry>
                      <ID>276</ID>
                      <Description>"isEnhance Test"</Description>
                      <LastState/>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>[ENABLE]
{$lua}
--if syntaxcheck then return end
local weapon = 0x001EAB90 --Long Sword
local equipWeapon = EquipParamWeapon:new(weapon,"isEnhanceTest")
equipWeapon:isEnhance(0)

[DISABLE]
{$lua}
--if syntaxcheck then return end

paramUtils:restore("isEnhanceTest")
</AssemblerScript>
                    </CheatEntry>
                    <CheatEntry>
                      <ID>277</ID>
                      <Description>"Scaling Test"</Description>
                      <LastState/>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>[ENABLE]
{$lua}
--if syntaxcheck then return end
local weapon = 0x001EAB90 --Long Sword
local equipWeapon = EquipParamWeapon:new(weapon,"ScalingTest")
equipWeapon:correctStrength(100)
equipWeapon:correctAgility(100)
equipWeapon:correctMagic(100)
equipWeapon:correctFaith(100)

[DISABLE]
{$lua}
--if syntaxcheck then return end

paramUtils:restore("ScalingTest")
</AssemblerScript>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>283</ID>
              <Description>"Magic"</Description>
              <Options moHideChildren="1"/>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}
if syntaxcheck then return end

--[[START Magic class]]--
Magic = BaseParamClass:new()

function Magic:new(id, uuid)
	local o = {}
	setmetatable(o, self)
	self.__index = self
	o.param = "Magic"
	o.id = id
	o.backupUuid = uuid

	o:init()
	o:stripIdForParams()
	return o
end




--[[END Magic class]]--

[DISABLE]
{$lua}
if syntaxcheck then return end

</AssemblerScript>
              <CheatEntries>
                <CheatEntry>
                  <ID>284</ID>
                  <Description>"EquipParamWeapon Tests"</Description>
                  <Options moHideChildren="1"/>
                  <LastState Value="" RealAddress="00000000"/>
                  <Color>C0C0C0</Color>
                  <GroupHeader>1</GroupHeader>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>285</ID>
                      <Description>"effectOnHit Test"</Description>
                      <LastState/>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>[ENABLE]
{$lua}
--if syntaxcheck then return end
local weapon = 0x001EAB90 --Long Sword
local equipWeapon = EquipParamWeapon:new(weapon,"effectOnHitTest")
equipWeapon:effectOnHit1(10564)
equipWeapon:effectOnHit2(112079000)
equipWeapon:effectOnHit3(110)

[DISABLE]
{$lua}
--if syntaxcheck then return end

paramUtils:restore("effectOnHitTest")
</AssemblerScript>
                    </CheatEntry>
                    <CheatEntry>
                      <ID>286</ID>
                      <Description>"isEnhance Test"</Description>
                      <LastState/>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>[ENABLE]
{$lua}
--if syntaxcheck then return end
local weapon = 0x001EAB90 --Long Sword
local equipWeapon = EquipParamWeapon:new(weapon,"isEnhanceTest")
equipWeapon:isEnhance(0)

[DISABLE]
{$lua}
--if syntaxcheck then return end

paramUtils:restore("isEnhanceTest")
</AssemblerScript>
                    </CheatEntry>
                    <CheatEntry>
                      <ID>287</ID>
                      <Description>"Scaling Test"</Description>
                      <LastState/>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>[ENABLE]
{$lua}
--if syntaxcheck then return end
local weapon = 0x001EAB90 --Long Sword
local equipWeapon = EquipParamWeapon:new(weapon,"ScalingTest")
equipWeapon:correctStrength(100)
equipWeapon:correctAgility(100)
equipWeapon:correctMagic(100)
equipWeapon:correctFaith(100)

[DISABLE]
{$lua}
--if syntaxcheck then return end

paramUtils:restore("ScalingTest")
</AssemblerScript>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>288</ID>
              <Description>"Bullet"</Description>
              <Options moHideChildren="1"/>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}
if syntaxcheck then return end

--[[START Bullet class]]--
Bullet = BaseParamClass:new()

function Bullet:new(id, uuid)
	local o = {}
	setmetatable(o, self)
	self.__index = self
	o.param = "Bullet"
	o.id = id
	o.backupUuid = uuid

	o:init()
	o:stripIdForParams()
	return o
end




--[[END Bullet class]]--

[DISABLE]
{$lua}
if syntaxcheck then return end

</AssemblerScript>
              <CheatEntries>
                <CheatEntry>
                  <ID>289</ID>
                  <Description>"EquipParamWeapon Tests"</Description>
                  <Options moHideChildren="1"/>
                  <LastState Value="" RealAddress="00000000"/>
                  <Color>C0C0C0</Color>
                  <GroupHeader>1</GroupHeader>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>290</ID>
                      <Description>"effectOnHit Test"</Description>
                      <LastState/>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>[ENABLE]
{$lua}
--if syntaxcheck then return end
local weapon = 0x001EAB90 --Long Sword
local equipWeapon = EquipParamWeapon:new(weapon,"effectOnHitTest")
equipWeapon:effectOnHit1(10564)
equipWeapon:effectOnHit2(112079000)
equipWeapon:effectOnHit3(110)

[DISABLE]
{$lua}
--if syntaxcheck then return end

paramUtils:restore("effectOnHitTest")
</AssemblerScript>
                    </CheatEntry>
                    <CheatEntry>
                      <ID>291</ID>
                      <Description>"isEnhance Test"</Description>
                      <LastState/>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>[ENABLE]
{$lua}
--if syntaxcheck then return end
local weapon = 0x001EAB90 --Long Sword
local equipWeapon = EquipParamWeapon:new(weapon,"isEnhanceTest")
equipWeapon:isEnhance(0)

[DISABLE]
{$lua}
--if syntaxcheck then return end

paramUtils:restore("isEnhanceTest")
</AssemblerScript>
                    </CheatEntry>
                    <CheatEntry>
                      <ID>292</ID>
                      <Description>"Scaling Test"</Description>
                      <LastState/>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>[ENABLE]
{$lua}
--if syntaxcheck then return end
local weapon = 0x001EAB90 --Long Sword
local equipWeapon = EquipParamWeapon:new(weapon,"ScalingTest")
equipWeapon:correctStrength(100)
equipWeapon:correctAgility(100)
equipWeapon:correctMagic(100)
equipWeapon:correctFaith(100)

[DISABLE]
{$lua}
--if syntaxcheck then return end

paramUtils:restore("ScalingTest")
</AssemblerScript>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>253</ID>
          <Description>"ParamUtils Tests"</Description>
          <Options moHideChildren="1"/>
          <LastState Value="" RealAddress="00000000"/>
          <Color>C0C0C0</Color>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>256</ID>
              <Description>"PatchInfo Test"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}
TestName = "PatchInfo"

local object = PatchInfo:new(12345,1337,PatchInfo.TYPE.FOUR_BYTE)

if(object == nil) then
  message("PatchInfo object shouldn't be nil")
elseif(object.address ~= 12345) then
  message("'object.address' should be '12345'")
elseif(object.value ~= 1337) then
  message("'object.value' should be '1337'")
elseif(object.valueType ~= PatchInfo.TYPE.FOUR_BYTE) then
  message("'object.valueType' should be 'PatchInfo.TYPE.FOUR_BYTE'")
elseif(PatchInfo.TYPE.BINARY ~= 0) then
  message("'PatchInfo.TYPE.BINARY' should be '0'")
elseif(PatchInfo.TYPE.BYTE ~= 1) then
  message("'PatchInfo.TYPE.BYTE' should be '1'")
elseif(PatchInfo.TYPE.TWO_BYTE ~= 2) then
  message("'PatchInfo.TYPE.BYTE' should be '2'")
elseif(PatchInfo.TYPE.FOUR_BYTE ~= 3) then
  message("'PatchInfo.TYPE.BYTE' should be '3'")
elseif(PatchInfo.TYPE.EIGHT_BYTE ~= 4) then
  message("'PatchInfo.TYPE.BYTE' should be '4'")
elseif(PatchInfo.TYPE.FLOAT ~= 5) then
  message("'PatchInfo.TYPE.FLOAT' should be '5'")
end

[DISABLE]
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>257</ID>
              <Description>"getIdAddress Test"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}
TestName = memrec.Description

local idTable = {
	10,
	12,
	13,
	14
}

local id = paramUtils:getIdAddress(idTable, 2)

if(id ~= 12) then
  message("'id' should be '12'")
end


[DISABLE]

</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>258</ID>
              <Description>"readValue Tests"</Description>
              <Options moHideChildren="1"/>
              <LastState Value="" RealAddress="00000000"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>259</ID>
                  <Description>"ReadValue Byte Test"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
TestName = memrec.Description

local darkHand = 0xA87500
local address = paramUtils:getIdAddressFromParam("EquipParamWeapon",darkHand)
local offset = 0xE3 -- wepmotionCategory
local info = PatchInfo:new(address + offset, 0, PatchInfo.TYPE.BYTE)
local value = paramUtils:readValue(info)

if(type(value) ~= "number") then
  message("'value' should be a number")
elseif(value ~= 42) then
  message("'value' should be '42'")
end

[DISABLE]
{$lua}

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>260</ID>
                  <Description>"ReadValue 2 Byte Test"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
TestName = "ReadValue 2 Byte"

local darkHand = 0xA87500
local address = paramUtils:GetIdAddressFromParam("EquipParamWeapon",darkHand)
local offset = 0xCE -- saWeaponDamage
local info = PatchInfo:new(address + offset, 0, PatchInfo.TYPE.TWO_BYTE)
local value = paramUtils:ReadValue(info)

if(type(value) ~= "number") then
  message("'value' should be a number")
elseif(value ~= 14) then
  message("'value' should be '14'")
end

[DISABLE]
{$lua}

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>254</ID>
                  <Description>"ReadValue 4 Byte Test"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
TestName = "ReadValue 4 Byte"

local darkHand = 0xA87500
local address = paramUtils:GetIdAddressFromParam("EquipParamWeapon",darkHand)
local offset = 0x14 -- fixPrice
local info = PatchInfo:new(address + offset, 0, PatchInfo.TYPE.FOUR_BYTE)
local value = paramUtils:ReadValue(info)

if(type(value) ~= "number") then
  message("'value' should be a number")
elseif(value ~= 550) then
  message("'value' should be '550' integer")
end

[DISABLE]
{$lua}

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>262</ID>
                  <Description>"ReadValue 8 Byte Test"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
TestName = "ReadValue 8 Byte"

local darkHand = 0xA87500
local address = paramUtils:GetIdAddressFromParam("EquipParamWeapon",darkHand)
local offset = 0xC4 -- attackBasePhysics
local info = PatchInfo:new(address + offset, 0, PatchInfo.TYPE.EIGHT_BYTE)
local value = paramUtils:ReadValue(info)

if(type(value) ~= "number") then
  message("'value' should be a number")
elseif(value ~= 88) then
  message("'value' should be '88' integer")
end

[DISABLE]
{$lua}

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>261</ID>
                  <Description>"ReadValue Float Test"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
TestName = "ReadValue Float"

local darkHand = 0xA87500
local address = paramUtils:GetIdAddressFromParam("EquipParamWeapon",darkHand)
local offset = 0x30 -- Physical Block
local info = PatchInfo:new(address + offset, 0, PatchInfo.TYPE.FLOAT)
local value = paramUtils:ReadValue(info)

if(type(value) ~= "number") then
  message("'value' should be a number")
elseif(value ~= 65.0) then
  message("'value' should be '65.0' float")
end

[DISABLE]
{$lua}

</AssemblerScript>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>263</ID>
              <Description>"patchValue Tests"</Description>
              <Options moHideChildren="1"/>
              <LastState Value="" RealAddress="00000000"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>264</ID>
                  <Description>"PatchValue Byte Test"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
TestName = "PatchValue Byte"

local darkHand = 0xA87500
local address = paramUtils:GetIdAddressFromParam("EquipParamWeapon",darkHand)
local offset = 0xE3 -- wepmotionCategory
local info = PatchInfo:new(address + offset, 69, PatchInfo.TYPE.BYTE)

paramUtils:PatchValue(info)

local value = paramUtils:ReadValue(info)

if(type(value) ~= "number") then
  message("'value' should be a number")
elseif(value ~= 69) then
  message("'value' should be '69' but it's "..value)
end

[DISABLE]
{$lua}

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>265</ID>
                  <Description>"PatchValue 2 Byte Test"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
TestName = "PatchValue 2 Byte"

local darkHand = 0xA87500
local address = paramUtils:GetIdAddressFromParam("EquipParamWeapon",darkHand)
local offset = 0xCE -- saWeaponDamage
local info = PatchInfo:new(address + offset, 33, PatchInfo.TYPE.TWO_BYTE)

paramUtils:PatchValue(info)

local value = paramUtils:ReadValue(info)

if(type(value) ~= "number") then
  message("'value' should be a number")
elseif(value ~= 33) then
  message("'value' should be '33'")
end

[DISABLE]
{$lua}

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>266</ID>
                  <Description>"PatchValue 4 Byte Test"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
TestName = "PatchValue 4 Byte"

local darkHand = 0xA87500
local address = paramUtils:GetIdAddressFromParam("EquipParamWeapon",darkHand)
local offset = 0x14 -- fixPrice
local info = PatchInfo:new(address + offset, 1337, PatchInfo.TYPE.FOUR_BYTE)

paramUtils:PatchValue(info)

local value = paramUtils:ReadValue(info)

if(type(value) ~= "number") then
  message("'value' should be a number")
elseif(value ~= 1337) then
  message("'value' should be '1337' integer")
end

[DISABLE]
{$lua}

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>267</ID>
                  <Description>"PatchValue 8 Byte Test"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
TestName = "PatchValue 8 Byte"

local darkHand = 0xA87500
local address = paramUtils:GetIdAddressFromParam("EquipParamWeapon",darkHand)
local offset = 0xC4 -- attackBasePhysics
local info = PatchInfo:new(address + offset, 85423, PatchInfo.TYPE.EIGHT_BYTE)

paramUtils:PatchValue(info)

local value = paramUtils:ReadValue(info)

if(type(value) ~= "number") then
  message("'value' should be a number")
elseif(value ~= 85423) then
  message("'value' should be '85423' integer")
end

[DISABLE]
{$lua}

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>268</ID>
                  <Description>"PatchValue Float Test"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
TestName = "PatchValue Float"

local darkHand = 0xA87500
local address = paramUtils:GetIdAddressFromParam("EquipParamWeapon",darkHand)
local offset = 0x30 -- Physical Block
local info = PatchInfo:new(address + offset, 13.0, PatchInfo.TYPE.FLOAT)

paramUtils:PatchValue(info)

local value = paramUtils:ReadValue(info)

if(type(value) ~= "number") then
  message("'value' should be a number")
elseif(value ~= 13.0) then
  message("'value' should be '13.0' float bit it's "..value)
end

[DISABLE]
{$lua}

</AssemblerScript>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
  </CheatEntries>
  <CheatCodes>
    <CodeEntry>
      <Description>Gestures access :mov eax,[rcx]</Description>
      <Address>14081D330</Address>
      <ModuleName>DarkSoulsIII.exe</ModuleName>
      <ModuleNameOffset>81D330</ModuleNameOffset>
      <Before>
        <Byte>72</Byte>
        <Byte>C1</Byte>
        <Byte>FF</Byte>
        <Byte>CC</Byte>
        <Byte>8B</Byte>
      </Before>
      <Actual>
        <Byte>8B</Byte>
        <Byte>01</Byte>
      </Actual>
      <After>
        <Byte>89</Byte>
        <Byte>02</Byte>
        <Byte>48</Byte>
        <Byte>8B</Byte>
        <Byte>C2</Byte>
      </After>
    </CodeEntry>
    <CodeEntry>
      <Description>HP :mov [rbx+000000D8],eax</Description>
      <Address>140E94AA7</Address>
      <ModuleName>DarkSoulsIII.exe</ModuleName>
      <ModuleNameOffset>E94AA7</ModuleNameOffset>
      <Before>
        <Byte>C8</Byte>
        <Byte>CE</Byte>
        <Byte>04</Byte>
        <Byte>8B</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>89</Byte>
        <Byte>83</Byte>
        <Byte>D8</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>85</Byte>
        <Byte>C0</Byte>
        <Byte>55</Byte>
        <Byte>48</Byte>
        <Byte>BD</Byte>
      </After>
    </CodeEntry>
  </CheatCodes>
  <UserdefinedSymbols>
    <SymbolEntry>
      <Name>newmem2</Name>
      <Address>08DB0000</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>BonFireAOB</Name>
      <Address>140BE4F8B</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>BonFireAOBOriginal</Name>
      <Address>13FFF0000</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>messageRepoP</Name>
      <Address>140E1683C</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>projectile</Name>
      <Address>14063C6E4</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>projectile_ptr</Name>
      <Address>13FFF0022</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>AttackAddressToUse</Name>
      <Address>08DB0000</Address>
    </SymbolEntry>
  </UserdefinedSymbols>
  <Comments>Hotkeys:
Ctrl+N - toggle Noclip
	
</Comments>
</CheatTable>
