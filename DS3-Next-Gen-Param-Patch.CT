<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="26">
  <Forms>
    <UDF2 Class="TCEForm" Encoding="Ascii85">jac1w8?CZwBzvvc(P}z[Cv8vAJvp[MN-L_jdu+LX3]L0,8[AMQ++?)ZxQpc=S@@sYE1JIQb;E/G)U/6p@hx;,uuDp@,JqP4Y5}m8H#6T1+!g@E;Fl*s:,0U1ps(s3*_;tQA8#Fr,@zh1B^}#xT*35gEw7yEYUSTcx8KRk6*XSv/aW1_V_8bhm%UO7/=iiilL/3OwX+l[kK{M;otPX8Ro?-SW2xjseh@E_uA!Ti.=C.G4y797smCiPwTf.HRIcv[fpg9G!vC${B^K9[O!S?bwe4,PUb/?P@3PftY:{norB;pzBdLT/hR)ns]$@Pc_M#:c%^d$Dy0mOC7[eR.xMK%u3=b{^k4h2s,1]wu7W)]H,hV8s^qyZ?Jp7HT55mwxUBVXT3c:n/mlk.ST3iTYMI({!,7xC,-=N_l6wXz4XKO19ClaZ+Ob{(BQnVE9vS0Gq,,;-3oXD{!6Ru31jBA,+yoQ7auXfm;o-)IdY%4xhF[Va^=L=g{Rzz7rAKPUEykx@Euh]n$uBxsRTWs0*KX$uYLS(Dg/j/b,G=_Lggsqc#5dN,ZMlfmF8(x7xoXFVWDL?%IK9P#!sjt*80!gWy#lMSv)fuA$uAUI:Fz9m[*GN5+sRPpel8+[3FBcB%+Ogf8:tTSBfEo*H5BUWGP-,+](P-Topuyq:TeFTEs79b4v0NLLOJkj1Ti..OL1jcP42,mDF^#]voEnLev=9!DZ48o,A:w}HGnso*8[Wtv%C@?N#-hDfwRCKzYcoGE/]coV%2:s,7M3i]v;RS+M(8(0k/OruNyVaH)R)G^2jf[#rz(B/.P)p+kShcigHPkJPsnqn*AJEe(pXjKA0vp,9$dhfA,)vUnP;xfUoYeplqu:[%tU9R;[mUMS(.Iodxh!R30oTm[aD*pLx?;Vu8J06]w3th7I5bWSwi$CMDL4HJw{Gqc?D9V$M#2KJe])(27L$bp[P*yi6,S!i8YEWKKQAY*hTS7yc4_As!8H[/MPs{)N3fe!H!m(@-k1-;c$5G,NMTUZiDGcD8NrBX+2TyE5Ju3aT1#b9T3C]JQnR#Qlun,]*IQ%R}]nDA@ddK2v-{$C=fQJp@4z;Tythv9ppI-@,sRvWDhJOuD/ocqc1Nx]9kZ:vblTRg=n+dVsj9J6bU-.5KeTn%m^0tXE@l}M($7J.E,XM]@b!2Z6_}bF+RU$E5-DBfDtF]8c]Ut,Hh)F!HhS:hBvsz**tI(*B1XFaw82?E(PT9MZy)/uGtj06GzS!vgmFb245?j!agt!N]w3-$k,;E5gB5dFFf?b4J,E0baZWTbPU_!wg9*:N}G4=@.)RiaRme/5b#bLRBl?v$KY@$wOiQQ3r!^M]xQ}.=-sHf:N9$VE4hWxZx;c_t4i=T@DgUieC-RzW!Y-F%8O[k66]n97M-KRq6Z(Yx96A0$8^VVu#}I,^QaK{ObE9oGd3zIF]z-g)b/$JJ?IUECQ4Ch.}-:H2#tI5^nuK_FtnIKXfY3NZZRD*/TtN(E?92t3ogos7EH*Z*]]BuN#d8dI}JbN/Hs;2(o4sf8s1cBRE;FwB.XilnnWcgI?T9rLR^Si5Z!i-0.$W:2Ys)O37Jpk=GE=;MKYYqyF@N(p-_[h!#c-XG)//G+opR[:B;0}hqkYdr7P-DlIqFUyk}FGV6y2ah*oP8n_=6a41;vLbo(K$@sCiZ)X61TQDN_+o={G:T(Sp1j=zYU4U{_{my+Vp;s5D5bU.}aF,PDIqF+0lXDT%scGzdXofALQKU%0KM3Dg[:Gwf[j=]72!!2!?h,xk#KL-b+$]-6yP]l/V^-35cbhjIy6-G{N+2XaB@1GHC1I5}:;11r{#}LAtzHge41kYz$J#:mLA/Ypa07vme1NT%%!5o4aDT+{DLRZx9HQoFKbBkK6(%4zwJ0Zst*:izfKq]1K?!2UsU]3hxnIqb30c(mb4iXlN86dQ#o3Ql;75xyvP1wG71#-us2e)tfO]1Q[YkXsizTi2LPrE!KFrr)9oDj:?@HCe]W1Pc.Gz4oAcL_y_]Uvhokpm]#RbfhOOWMynRQg*,63t#9THQ+ra{jzh(oYFCc1K?bYLbXD6l9@Gci5$z(-A65Q(kGK$Wi;AXmGW!$44BYKZI/GVLb2iRjsJk5t2Bapc#e%D2U0p/1FftWsS#iPglWI5Dr]=rrF1=IBB*fS[@$lL{3I5z32}TdW@eKJZ{Jjq.s@HqL}oq,#fxCiAiOL^T1jDtB],MLEGFW(]Ah.7_zIc(+TpmA.NtP5MQmo[Izl[ZPv/:*yJ5=)/Xr{GW!SvYVz?Hgq,MN8c^Eh3{+ESrr=amAq-4B!@;oDIxlUAJgH][=I/*5B-P=!PF/=CZ[NmFW$L@WTsn-P85wnWt@8hN*:}}_cv}}NauqE4ZCiXVX}N!{M/*0MY{mCi3%BD]c#{!E=Zkc-#1,L!;tyP=Q=tm/W_as_d6I$%1WtSixLokE7IRqcE/k_NuNtLFyS4@KTmdfhJ4)=_v{Dhmd@^hb]ev4LWqw2O+oE?,=_;3rVY}%VpRN?EN:[/DLF/JiREHq{rbszlF$i}5ADRo1S71HMrkKH5;9e#48#!4;/VRhPm%w={1k./z.^7JOyS3AsbjONWj;be;=pf[K%z%c(:v:rN5l3(3F9/#u@ivJ/33hhj,u*?u[,uFFYeon14cGCg-)1KMwt8ZlsT#YmS:ZwNw2]ng%2K,#D2?A-qPtL]EnV}AcrHsCcX}9om$:7SR$(c?Z)v$:z)o@w-p0!4k-z)Kdrss9v8{:0k=5J/7DB$]dpKHnPL=GpnJc]l3AlLc0yDDHl{wYWs5.TA]_jzp:iAS;fy=sAYs$.N.1)R)OezHpFjsyv0Np+j[M-r:sxT/13+4EvdQbZAhoUd}ORKMe2zt](*4RjeU_QMZ#??MW=OS1x)!5,f/D)N_pXH[1p)uxxLCZ@?.[)P3yJC3;pZ?^</UDF2>
    <UDF1 Class="TCEForm" Encoding="Ascii85">y[wH$,cp?$B^^MDCy84pZI)j.0Xeh-Hn,hrU_4(Jl@6,^ELrTdKyI_f,JtFQpqM4?w)EdB!gk)u$34UL2D_Q2MvAgzDWdGDSuc)*TA#k)=.{5n(eI*D;z#LAm[7TjL,E7X?{RS}asuD6)$7Zu2%[PLm447mJ;r!P[0[k=VWZM-x?iNCA;x+w9Wywwjt^I8/TGmsT{S}V*ap.I$(j^=]?VIK!4%Rp8zbnlC{LfHo(_hl6W3:HAeZ@AQ^,b9,e!]0PN/v^ABhyqhDQ#dKW4/Uc_b[D3THV1eTXZ#k9(k+zieMqpHQ/tphv*U(IykeKpM4;)P#*nqb3QBClO$oi2$F}(jIDpZGs7^Xz=Z1[$5vOzbXRQf4uJwMuc^e14Zx[Pn{VM%[xt{*EC4XvkH9LCXA8Eqj.DnbNBRSay(X*a.qWtvLU{^wh470=RsE/,,j-!iO6e^8JCj2(NF*rr)zB$.S,_62{pz{D#6W]?Z_ytV;q;t.8RMd@6a]E#OnIbYbs]7K0-kOrQfw_16IBP),{8][z!q$7r-4t:Pd+tU#uz%v8Q4V.]56d[+-G%D(IhZ26*zu/jd@@HedixeWtW/M@]Z!cfu5P?;0*s?=ycd7_cMGI%:X]BLuOtxG?()eA3a/=R[[dd-@a57l21;6/:npBx^I%1TlmQX8fFiVpX0CP[+s6%r/bDU+3)0z+^*uMSb=@giw]%w5ehm)ou?e@/TAY8N2y1%0M70C2Rx_D7o=51hd=@9:Iz05D:VR6#h;I^9!**Itb97[XS*2O?N;6,vGdw0,+;Qq,{IykqT1O$YVX+NO#fgK!83UgrrI+;paVE2*]k}A*)VHdPMOi?E[aYs{QuE,XmNMVhzIVm5?!I,?%j]Z_Xs)gD?AaB2D?zR^3O%^K89gmW{:?tH#gbS/eKI@*3MVIt4HGN^0=(n}:XO37[Gqn1PHy]5Lz4)F-9WinMxm!+@=2;ETowa.f_gHIMB./5%HM?E@@T:lk[lFy/p:Fcv46U;ro#vNW%5CJ$c7]c!)Le/qF[TBQqdmjTKQt.+k=KzGP%rfFJD%sal+Y=IqH%;VYuZSLknGJeoxk^UkH.wSOAJdjAj9uXh90z{T*#%$yLmloK+3T@,S:i9D.v5cOny@+on8]-7UN+/L#jYdtR7_sJNE_.EadNGcAPdHb+eDP^=5Bkiti5F}(jt]FDZBm_G?TI-+M,;79xeKkuwz6?z.!Y?uEO8{OGuR26fzu-+DgKI*+C(8FdHpa{RlFa?F[!6vSBZsO]h2D+d!?!jHkE5}W{qnybVuZ7as59w]hE03l^vnHy2l:P0fBSo.%PNDZz#:Ix%u]r()OWI7V.aSdQmkda3X$A8(DL=^nVP.3DA49N%OsWO.z?/8R==.u$tM66dfj7at^TKC2[209O%/nNJ(k800,vAcUn:wjdy0)DgC0U6fF;.Am$*+#4Gc{O]d@RW@,_qj,w^24]v:lGVkgN/^y]3ZuZD/h?s]gC@7V@Y%QmJLZ*YB^[OtW=$vjmCc@Q_b]h/aZv#0]X6:IN:_%IgZr_%C$c28Z%YqGzUf%A4iI:o+F=h=gxC[.}0{hVcfcoZ!=}Ag(fs}.Ez.U6//^RXrK86*#r%L:NWRq)+:TSNFaBvTgZmDtv_I095hf]IrcX-HFIJTC!x!2=e?dbXP+Zu[</UDF1>
    <BACForm Class="TCEForm" Encoding="Ascii85">jgrld):ZT#9p{H/Kdq1uh)kEQa*1=DaoFoN-KZ.qsMJVsO+d^EDUBn=3)X5}.lwj:.)d4ko]N(B/D[Y6l%B=xXTHpQlivma.lzJyhTg4?$.uqwcsyzWnp5;JG^z]dEUEevs3FePABz4diRn]PqnKWl)+$S6@I:JmdqYT6x+pEHAVLvwXQi7g2wp]Qc^uXY1ZA^AIn{*.Src3(9A%#6[)POryaA6TAOd)[w^b$vF/SE_]hqWITktXO3YxO1+NPQJvyUW31OjV^)kYDyg{]RV0A(lhga81GA%kd!Qj0Ogp?Ql*@i*8d3JM:JgQ[gwnM8zj:HV0+3jmw3h7XkD=3g]zI4]SPrSF$gBcBMQE_FIaQsX6=rj/7FOb}[7HuQ4]@nC,0Wz}jjw5J{S]_hdV^696z-/i5u3VZ5Y%Bwv})K=sX63L*[A{^)x;RTcOu},290V2)o$N}TFi+A+H/UMP6x}S-oX@Y2Bo#Q/@=E]e43T(THzfb6)%^-UPUZws4N{aY,KgAL4R,;uQ)}VM5)WO+8b{C*(Q3=-HDzJS?:Y2{mEv1s#t8^+VQmduZs3zDEAattVfrPziU@0D2sKaO.Ud]_juTQFs]dWb{TV}a7H8;vJQM9T+YV+ro7Na$U$NXGePAN(UMWGlP_ECP(%B_u%8LveI]jnO[GEeS^5yANgf6aoVXia;ig:kIdGPbRM</BACForm>
  </Forms>
  <CheatEntries>
    <CheatEntry>
      <ID>249</ID>
      <Description>"ParamUtils"</Description>
      <Options moHideChildren="1"/>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
{$lua}
--if syntaxcheck then return end

--[[START PatchInfo class
	Author: Igromanru
	Description: Entity with informations (address, value and valueType).
					Also enum TYPE, with all possible value types.
]]--
PatchInfo = {
	address = 0,
	value = 0,
	valueType = 0,
	TYPE = {
		BYTE = 0,
		TWO_BYTE = 1,
		FOUR_BYTE = 2,
		EIGHT_BYTE = 3,
		FLOAT = 4,
		UINT = 5
	}
}

function PatchInfo:new(address, value, valueType)
	local o = {}
	setmetatable(o, self)
	self.__index = self
	if(address ~= nil) then
		o.address = address
	end
	if(value ~= nil) then
		o.value = value
	end
	if(valueType ~= nil) then
		o.valueType = valueType
	end

	return o
end

--[[END PatchInfo class]]--

--[[START ParamUtils class
	Author: Igromanru
	Description: Utils class for Params
]]--
ParamUtils = {
	masterParamTable = {},
	patchBackUp = {},
    patchBackUpOld = {},
}

function ParamUtils:new()
	local function readIntegerSafe(Input)
		local Value = readInteger(Input)
		if Value &lt; 2147483647 then
			return Value
		else
			return Value - 0x100000000
		end
	end
	local function InitializeAddress()
		autoAssemble([[
			aobscanmodule(ParamPatchBase,DarkSoulsIII.exe,48 8B 0D ? ? ? ? 48 85 C9 74 0B 4C 8B C0 48 8B D7)
			registersymbol(ParamPatchBase)
		]])
		local addr = getAddress("ParamPatchBase")
		addr = addr + readIntegerSafe(addr + 0x3) + 7
		addr = readQword(addr)+ 0x10
		unregisterSymbol("ParamPatch")
		registerSymbol("ParamPatch", addr, true)
	end
	local o = {}
	setmetatable(o, self)
	self.__index = self

    InitializeAddress()
	o:paramIndexer()
	return o
end

function ParamUtils:destroy()
	unregisterSymbol("ParamPatchBase")
	unregisterSymbol("ParamPatch")
end

function ParamUtils:toHex(number)
  return string.format("%X",number)
end

function ParamUtils:error(message)
  error("ParamUtils Error:\r\n"..message)
end

function ParamUtils:paramIndexer()
	local Param = getAddress("ParamPatch")
	local Start = readQword(Param)
	local End = readQword(Param+8)
	local Count = (End-Start)/8
	self.masterParamTable = {}

	for i = 0, Count - 1 do
	  local ParamOffset = readQword(Start+i*8)
	  local ParamString = "Unknown"
	  if readInteger(ParamOffset+0x20) &gt; 7 then
		 ParamString = readString(readQword(ParamOffset+0x10),90,true)
	  else
		 ParamString = readString(ParamOffset+0x10,90,true)
	  end
	  self.masterParamTable[ParamString] = ParamOffset
	end
end

function ParamUtils:getIdAddress(IdTable, Id)
	local result = IdTable[Id]
	if result == nil then
		showMessage("ID:"..Id.." (hex:"..self:toHex(Id) ..") couldn't be found")
	end
	return result
end

function ParamUtils:getParamIdTable(ParamName)
	local IDTable = {}
	local ParamAddr = readQword(readQword(self.masterParamTable[ParamName]+0x68)+0x68)
	local TableCount = byteTableToWord(readBytes(ParamAddr+0xa,2,true))
	for i=0,TableCount-1 do
		local PID = readInteger(ParamAddr+0x40+0x18*i)
		local IDO = readInteger(ParamAddr+0x48+0x18*i)
		IDTable[PID] = ParamAddr + IDO
	end
	return IDTable
end

function ParamUtils:getIdAddressFromParam(paramName, id)
	local result = 0
	local idTable = self:getParamIdTable(paramName)

	if(idTable ~= nil) then
		result = self:getIdAddress(idTable, id)
	end
	return result
end

function ParamUtils:paramIterator(ParamName,ChangeTable,uuid)
	local IDTable = self:getParamIdTable(ParamName)
	if uuid ~= nil then --Make a table for backups
		if self.patchBackUpOld == nil then
			self.patchBackUpOld = {}
		end
		self.patchBackUpOld[uuid] = {}
		for k,v in pairs(ChangeTable) do
			local Backup = {}
			local _,DataLength = string.gsub(v[3], "%x+","")
			local idAddress = self:getIdAddress(IDTable,v[1])
			if idAddress ~= nil then
				Backup[1] = idAddress + v[2]
				Backup[2] = readBytes(Backup[1],DataLength,true)
				table.insert(self.patchBackUpOld[uuid],Backup)
				self:paramPatcher(idAddress,v[2],v[3],v[4])
			end
		end
	else
		for k,v in pairs(ChangeTable) do
			local idAddress = getIdAddress(IDTable,v[1])
			if idAddress ~= nil then
				self:paramPatcher(idAddress,v[2],v[3],v[4])
			end
		end
	end
end

function ParamUtils:paramPatcher(idAddress,DataOffset,Data,Symbol)
	local WriteAddr = idAddress+DataOffset
	local HexTable = {}
	if Symbol == nil then
		for word in string.gmatch(Data, "%x+") do table.insert(HexTable,tonumber(word,16)) end
		writeBytes(WriteAddr,HexTable)
	else
		registerSymbol(Symbol,WriteAddr,true)
	end
end

function ParamUtils:paramDepatcher(uuid)
	for k,v in pairs(self.patchBackUpOld[uuid]) do
		writeBytes(v[1],v[2])
	end
	self.patchBackUpOld[uuid] = nil
end

function ParamUtils:patchMultipleOffsets(paramName, id, patchInfoTable, uuid)
	if(self.patchBackUp[uuid] == nil) then
		local address = getIdAddressFromParam()
		for key,patchInfo in pairs(patchInfoTable) do
			patchInfo.address = address
			self:patchValueWithBackup(patchInfo,uuid)
		end
	else
		showMessage("Error: The UUID "..uuid.." is already in use.")
	end
end

function ParamUtils:restore(...)
	local arg = table.pack(...)
	for i,uuid in ipairs(arg) do
		for index,patchInfo in ipairs(self.patchBackUp[uuid]) do
			--showMessage("Restore: address:"..self:toHex(patchInfo.address).." value:"..patchInfo.value.." uuid:"..uuid)
			self:patchValue(patchInfo)
		end
		self.patchBackUp[uuid] = nil
	end
end

function ParamUtils:patchValueWithBackup(patchInfo, uuid)
	local readValue = self:readValue(patchInfo)
	self:patchValue(patchInfo)
	table.insert(self.patchBackUp[uuid], PatchInfo:new(patchInfo.address, readValue, patchInfo.valueType))
end

function ParamUtils:readValue(patchInfo)
	local value = 0
	if(patchInfo.valueType == PatchInfo.TYPE.BYTE) then
		value = readBytes(patchInfo.address, 1)
	elseif(patchInfo.valueType == PatchInfo.TYPE.TWO_BYTE) then
		value = byteTableToWord(readBytes(patchInfo.address, 2, true))
	elseif(patchInfo.valueType == PatchInfo.TYPE.FOUR_BYTE or patchInfo.valueType == PatchInfo.TYPE.UINT) then
		value = readInteger(patchInfo.address)
	elseif(patchInfo.valueType == PatchInfo.TYPE.EIGHT_BYTE) then
		value = readQword(patchInfo.address)
	elseif(patchInfo.valueType == PatchInfo.TYPE.FLOAT) then
		value = readFloat(patchInfo.address)
	end
	return value
end

function ParamUtils:patchValue(patchInfo)
	if(patchInfo.valueType == PatchInfo.TYPE.BYTE) then
		if(patchInfo.value &gt; 255) then
			self:error("Byte can't be bigger then 255")
		elseif(patchInfo.value &lt; 0) then
			self:error("Byte can't be smaller then 0")
		else
			writeBytes(patchInfo.address, patchInfo.value)
		end
	elseif(patchInfo.valueType == PatchInfo.TYPE.TWO_BYTE) then
		if(patchInfo.value &gt; 65535) then
			self:error("2 Bytes can't be bigger then 65535")
		elseif(patchInfo.value &lt; 0) then
			self:error("2 Bytes can't be smaller then 0")
		else
			writeBytes(patchInfo.address, wordToByteTable(patchInfo.value))
		end
	elseif(patchInfo.valueType == PatchInfo.TYPE.FOUR_BYTE) then
		if(patchInfo.value &gt; 2147483647) then
			self:error("4 Bytes can't be bigger then 2147483647")
		elseif(patchInfo.value &lt; -2147483648) then
			self:error("4 Bytes can't be smaller then -2147483648")
		else
			writeInteger(patchInfo.address, patchInfo.value)
		end
	elseif(patchInfo.valueType == PatchInfo.TYPE.EIGHT_BYTE) then
		if(patchInfo.value &gt; 9223372036854775807) then
			self:error("8 Bytes can't be bigger then 9223372036854775807")
		elseif(patchInfo.value &lt; -9223372036854775808) then
			self:error("8 Bytes can't be smaller then -9223372036854775808")
		else
			writeQword(patchInfo.address, patchInfo.value)
		end
	elseif(patchInfo.valueType == PatchInfo.TYPE.FLOAT) then
		if(patchInfo.value &gt; 3.4028235E38) then
			self:error("Float can't be bigger then 3.4028235E38")
		elseif(patchInfo.value &lt; -3.4028235E38) then
			self:error("Float can't be smaller then -3.4028235E38")
		else
			writeFloat(patchInfo.address, patchInfo.value)
		end
	elseif(patchInfo.valueType == PatchInfo.TYPE.UINT) then
		if(patchInfo.value &gt; 4294967295) then
			self:error("Unsinged integer can't be bigger then 4294967295")
		elseif(patchInfo.value &lt; 0) then
			self:error("Unsinged integer can't be smaller then 0")
		else
			writeInteger(patchInfo.address, patchInfo.value)
		end
	end
end

-- Creating an instance of ParamUtils
paramUtils = ParamUtils:new()
--[[END ParamUtils class]]--

TestName = ""
-- Tests Part
function message(msg)
  showMessage(TestName.." Error: "..msg)
end

[DISABLE]
{$lua}
if syntaxcheck then return end
paramUtils:destroy()

</AssemblerScript>
      <CheatEntries>
        <CheatEntry>
          <ID>252</ID>
          <Description>"BaseParamClass"</Description>
          <Options moHideChildren="1"/>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
{$lua}
if syntaxcheck then return end

--[[START BaseParamClass class]]--
BaseParamClass = {
	id = 0,
	param = "",
	backupUuid = "",
	address = 0
}

function BaseParamClass:new(o)
	o = o or {}
	setmetatable(o, self)
	self.__index = self

	return o
end

function BaseParamClass:init()
	paramUtils.patchBackUp[self.backupUuid] = {}
	self.address = paramUtils:getIdAddressFromParam(self.param, self.id)
end

function BaseParamClass:patchValue(offset, value, valueType)
	local patchInfo = PatchInfo:new(self.address + offset, value, valueType)
	paramUtils:patchValueWithBackup(patchInfo, self.backupUuid)
end

function BaseParamClass:patchByte(offset, value)
	self:patchValue(offset, value, PatchInfo.TYPE.BYTE)
end

function BaseParamClass:patch2Byte(offset, value)
	self:patchValue(offset, value, PatchInfo.TYPE.TWO_BYTE)
end

function BaseParamClass:patch4Byte(offset, value)
	self:patchValue(offset, value, PatchInfo.TYPE.FOUR_BYTE)
end

function BaseParamClass:patch8Byte(offset, value)
	self:patchValue(offset, value, PatchInfo.TYPE.EIGHT_BYTE)
end

function BaseParamClass:patchFloat(offset, value)
	self:patchValue(offset, value, PatchInfo.TYPE.FLOAT)
end


--[[END BaseParamClass class]]--

[DISABLE]
{$lua}
if syntaxcheck then return end

</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>251</ID>
              <Description>"EquipParamWeapon"</Description>
              <Options moHideChildren="1"/>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}
if syntaxcheck then return end

--[[START EquipParamWeapon class]]--
EquipParamWeapon = BaseParamClass:new()

function EquipParamWeapon:new(id, uuid)
	local o = {}
	setmetatable(o, self)
	self.__index = self
	o.param = "EquipParamWeapon"
	o.id = id
	o.backupUuid = uuid

	o:init()
	return o
end

function EquipParamWeapon:behaviorId(value)
	self:patch4Byte(0x0, value)
end

function EquipParamWeapon:sortId(value)
	self:patch4Byte(0x4, value)
end

function EquipParamWeapon:wanderingEquipId(value)
	self:patch4Byte(0x8, value)
end

function EquipParamWeapon:weight(value)
	self:patchFloat(0xC, value)
end

function EquipParamWeapon:weight(value)
	self:patchFloat(0x10, value)
end

function EquipParamWeapon:fixPrice(value)
	self:patch4Byte(0x14, value)
end

function EquipParamWeapon:basicPrice(value)
	self:patch4Byte(0x18, value)
end

function EquipParamWeapon:sellValue(value)
	self:patch4Byte(0x1C, value)
end

function EquipParamWeapon:correctStrength(value)
	self:patchFloat(0x20, value)
end

function EquipParamWeapon:correctAgility(value)
	self:patchFloat(0x24, value)
end

function EquipParamWeapon:correctMagic(value)
	self:patchFloat(0x28, value)
end

function EquipParamWeapon:correctFaith(value)
	self:patchFloat(0x2C, value)
end

function EquipParamWeapon:physGuardCutRate(value)
	self:patchFloat(0x30, value)
end

function EquipParamWeapon:magGuardCutRate(value)
	self:patchFloat(0x34, value)
end

function EquipParamWeapon:fireGuardCutRate(value)
	self:patchFloat(0x38, value)
end

function EquipParamWeapon:thunGuardCutRate(value)
	self:patchFloat(0x3C, value)
end

function EquipParamWeapon:effectOnHit1(value)
	self:patch4Byte(0x40, value)
end

function EquipParamWeapon:effectOnHit2(value)
	self:patch4Byte(0x44, value)
end

function EquipParamWeapon:effectOnHit3(value)
	self:patch4Byte(0x48, value)
end

function EquipParamWeapon:effectOnSelf1(value)
	self:patch4Byte(0x4C, value)
end

function EquipParamWeapon:effectOnSelf2(value)
	self:patch4Byte(0x50, value)
end

function EquipParamWeapon:effectOnSelf3(value)
	self:patch4Byte(0x54, value)
end

-- Insert Origin Equip Weapon offsets here

-- Insert Anti Damage Rate offsets here

-- Insert AC-BA here

function EquipParamWeapon:durability(value)
	self:patch2Byte(0xBC, value)
end

function EquipParamWeapon:durabilityMax(value)
	self:patch2Byte(0xBE, value)
end

-- Insert C0-C2 here

function EquipParamWeapon:attackBasePhysics(value)
	self:patch2Byte(0xC4, value)
end

function EquipParamWeapon:attackBaseMagic(value)
	self:patch2Byte(0xC6, value)
end

function EquipParamWeapon:attackBaseFire(value)
	self:patch2Byte(0xC8, value)
end

function EquipParamWeapon:attackBaseThunder(value)
	self:patch2Byte(0xCa, value)
end

function EquipParamWeapon:attackBaseStamina(value) -- Stamina consuption to block
	self:patch2Byte(0xCC, value)
end

-- Insert CE-ED here

-- Requirements
function EquipParamWeapon:properStrength(value)
	self:patchByte(0xEE, value)
end

function EquipParamWeapon:properAgility(value)
	self:patchByte(0xEF, value)
end

function EquipParamWeapon:properMagic(value)
	self:patchByte(0xF0, value)
end

function EquipParamWeapon:properFaith(value)
	self:patchByte(0xF1, value)
end

--[[END EquipParamWeapon class]]--

[DISABLE]
{$lua}
if syntaxcheck then return end

</AssemblerScript>
              <CheatEntries>
                <CheatEntry>
                  <ID>269</ID>
                  <Description>"EquipParamWeapon Tests"</Description>
                  <Options moHideChildren="1"/>
                  <LastState Value="" RealAddress="00000000"/>
                  <Color>C0C0C0</Color>
                  <GroupHeader>1</GroupHeader>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>270</ID>
                      <Description>"effectOnHit Test"</Description>
                      <LastState/>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>[ENABLE]
{$lua}
--if syntaxcheck then return end
local weapon = 0x5F39BC --Chaos Dark Sword
local equipWeapon = EquipParamWeapon:new(weapon,"effectOnHitTest")
equipWeapon:effectOnHit1(10564)
equipWeapon:effectOnHit2(112079000)
equipWeapon:effectOnHit3(110)

[DISABLE]
{$lua}
--if syntaxcheck then return end

paramUtils:restore("effectOnHitTest")
</AssemblerScript>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>253</ID>
          <Description>"ParamUtils Tests"</Description>
          <Options moHideChildren="1"/>
          <LastState Value="" RealAddress="00000000"/>
          <Color>C0C0C0</Color>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>256</ID>
              <Description>"PatchInfo Test"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}
TestName = "PatchInfo"

local object = PatchInfo:new(12345,1337,PatchInfo.TYPE.FOUR_BYTE)

if(object == nil) then
  message("PatchInfo object shouldn't be nil")
elseif(object.address ~= 12345) then
  message("'object.address' should be '12345'")
elseif(object.value ~= 1337) then
  message("'object.value' should be '1337'")
elseif(object.valueType ~= PatchInfo.TYPE.FOUR_BYTE) then
  message("'object.valueType' should be 'PatchInfo.TYPE.FOUR_BYTE'")
elseif(PatchInfo.TYPE.BYTE ~= 0) then
  message("'PatchInfo.TYPE.BYTE' should be '0'")
elseif(PatchInfo.TYPE.TWO_BYTE ~= 1) then
  message("'PatchInfo.TYPE.BYTE' should be '1'")
elseif(PatchInfo.TYPE.FOUR_BYTE ~= 2) then
  message("'PatchInfo.TYPE.BYTE' should be '2'")
elseif(PatchInfo.TYPE.EIGHT_BYTE ~= 3) then
  message("'PatchInfo.TYPE.BYTE' should be '3'")
elseif(PatchInfo.TYPE.FLOAT ~= 4) then
  message("'PatchInfo.TYPE.FLOAT' should be '4'")
end

[DISABLE]
{$lua}

</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>257</ID>
              <Description>"getIdAddress Test"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}
TestName = memrec.Description

local idTable = {
	10,
	12,
	13,
	14
}

local id = paramUtils:getIdAddress(idTable, 2)

if(id ~= 12) then
  message("'id' should be '12'")
end


[DISABLE]

</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>258</ID>
              <Description>"readValue Tests"</Description>
              <Options moHideChildren="1"/>
              <LastState Value="" RealAddress="00000000"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>259</ID>
                  <Description>"ReadValue Byte Test"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
TestName = memrec.Description

local darkHand = 0xA87500
local address = paramUtils:getIdAddressFromParam("EquipParamWeapon",darkHand)
local offset = 0xE3 -- wepmotionCategory
local info = PatchInfo:new(address + offset, 0, PatchInfo.TYPE.BYTE)
local value = paramUtils:readValue(info)

if(type(value) ~= "number") then
  message("'value' should be a number")
elseif(value ~= 42) then
  message("'value' should be '42'")
end

[DISABLE]
{$lua}

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>260</ID>
                  <Description>"ReadValue 2 Byte Test"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
TestName = "ReadValue 2 Byte"

local darkHand = 0xA87500
local address = paramUtils:GetIdAddressFromParam("EquipParamWeapon",darkHand)
local offset = 0xCE -- saWeaponDamage
local info = PatchInfo:new(address + offset, 0, PatchInfo.TYPE.TWO_BYTE)
local value = paramUtils:ReadValue(info)

if(type(value) ~= "number") then
  message("'value' should be a number")
elseif(value ~= 14) then
  message("'value' should be '14'")
end

[DISABLE]
{$lua}

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>254</ID>
                  <Description>"ReadValue 4 Byte Test"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
TestName = "ReadValue 4 Byte"

local darkHand = 0xA87500
local address = paramUtils:GetIdAddressFromParam("EquipParamWeapon",darkHand)
local offset = 0x14 -- fixPrice
local info = PatchInfo:new(address + offset, 0, PatchInfo.TYPE.FOUR_BYTE)
local value = paramUtils:ReadValue(info)

if(type(value) ~= "number") then
  message("'value' should be a number")
elseif(value ~= 550) then
  message("'value' should be '550' integer")
end

[DISABLE]
{$lua}

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>262</ID>
                  <Description>"ReadValue 8 Byte Test"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
TestName = "ReadValue 8 Byte"

local darkHand = 0xA87500
local address = paramUtils:GetIdAddressFromParam("EquipParamWeapon",darkHand)
local offset = 0xC4 -- attackBasePhysics
local info = PatchInfo:new(address + offset, 0, PatchInfo.TYPE.EIGHT_BYTE)
local value = paramUtils:ReadValue(info)

if(type(value) ~= "number") then
  message("'value' should be a number")
elseif(value ~= 88) then
  message("'value' should be '88' integer")
end

[DISABLE]
{$lua}

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>261</ID>
                  <Description>"ReadValue Float Test"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
TestName = "ReadValue Float"

local darkHand = 0xA87500
local address = paramUtils:GetIdAddressFromParam("EquipParamWeapon",darkHand)
local offset = 0x30 -- Physical Block
local info = PatchInfo:new(address + offset, 0, PatchInfo.TYPE.FLOAT)
local value = paramUtils:ReadValue(info)

if(type(value) ~= "number") then
  message("'value' should be a number")
elseif(value ~= 65.0) then
  message("'value' should be '65.0' float")
end

[DISABLE]
{$lua}

</AssemblerScript>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>263</ID>
              <Description>"patchValue Tests"</Description>
              <Options moHideChildren="1"/>
              <LastState Value="" RealAddress="00000000"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>264</ID>
                  <Description>"PatchValue Byte Test"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
TestName = "PatchValue Byte"

local darkHand = 0xA87500
local address = paramUtils:GetIdAddressFromParam("EquipParamWeapon",darkHand)
local offset = 0xE3 -- wepmotionCategory
local info = PatchInfo:new(address + offset, 69, PatchInfo.TYPE.BYTE)

paramUtils:PatchValue(info)

local value = paramUtils:ReadValue(info)

if(type(value) ~= "number") then
  message("'value' should be a number")
elseif(value ~= 69) then
  message("'value' should be '69' but it's "..value)
end

[DISABLE]
{$lua}

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>265</ID>
                  <Description>"PatchValue 2 Byte Test"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
TestName = "PatchValue 2 Byte"

local darkHand = 0xA87500
local address = paramUtils:GetIdAddressFromParam("EquipParamWeapon",darkHand)
local offset = 0xCE -- saWeaponDamage
local info = PatchInfo:new(address + offset, 33, PatchInfo.TYPE.TWO_BYTE)

paramUtils:PatchValue(info)

local value = paramUtils:ReadValue(info)

if(type(value) ~= "number") then
  message("'value' should be a number")
elseif(value ~= 33) then
  message("'value' should be '33'")
end

[DISABLE]
{$lua}

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>266</ID>
                  <Description>"PatchValue 4 Byte Test"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
TestName = "PatchValue 4 Byte"

local darkHand = 0xA87500
local address = paramUtils:GetIdAddressFromParam("EquipParamWeapon",darkHand)
local offset = 0x14 -- fixPrice
local info = PatchInfo:new(address + offset, 1337, PatchInfo.TYPE.FOUR_BYTE)

paramUtils:PatchValue(info)

local value = paramUtils:ReadValue(info)

if(type(value) ~= "number") then
  message("'value' should be a number")
elseif(value ~= 1337) then
  message("'value' should be '1337' integer")
end

[DISABLE]
{$lua}

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>267</ID>
                  <Description>"PatchValue 8 Byte Test"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
TestName = "PatchValue 8 Byte"

local darkHand = 0xA87500
local address = paramUtils:GetIdAddressFromParam("EquipParamWeapon",darkHand)
local offset = 0xC4 -- attackBasePhysics
local info = PatchInfo:new(address + offset, 85423, PatchInfo.TYPE.EIGHT_BYTE)

paramUtils:PatchValue(info)

local value = paramUtils:ReadValue(info)

if(type(value) ~= "number") then
  message("'value' should be a number")
elseif(value ~= 85423) then
  message("'value' should be '85423' integer")
end

[DISABLE]
{$lua}

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>268</ID>
                  <Description>"PatchValue Float Test"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
TestName = "PatchValue Float"

local darkHand = 0xA87500
local address = paramUtils:GetIdAddressFromParam("EquipParamWeapon",darkHand)
local offset = 0x30 -- Physical Block
local info = PatchInfo:new(address + offset, 13.0, PatchInfo.TYPE.FLOAT)

paramUtils:PatchValue(info)

local value = paramUtils:ReadValue(info)

if(type(value) ~= "number") then
  message("'value' should be a number")
elseif(value ~= 13.0) then
  message("'value' should be '13.0' float bit it's "..value)
end

[DISABLE]
{$lua}

</AssemblerScript>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
  </CheatEntries>
  <CheatCodes>
    <CodeEntry>
      <Description>Gestures access :mov eax,[rcx]</Description>
      <Address>14081D330</Address>
      <ModuleName>DarkSoulsIII.exe</ModuleName>
      <ModuleNameOffset>81D330</ModuleNameOffset>
      <Before>
        <Byte>72</Byte>
        <Byte>C1</Byte>
        <Byte>FF</Byte>
        <Byte>CC</Byte>
        <Byte>8B</Byte>
      </Before>
      <Actual>
        <Byte>8B</Byte>
        <Byte>01</Byte>
      </Actual>
      <After>
        <Byte>89</Byte>
        <Byte>02</Byte>
        <Byte>48</Byte>
        <Byte>8B</Byte>
        <Byte>C2</Byte>
      </After>
    </CodeEntry>
    <CodeEntry>
      <Description>HP :mov [rbx+000000D8],eax</Description>
      <Address>140E94AA7</Address>
      <ModuleName>DarkSoulsIII.exe</ModuleName>
      <ModuleNameOffset>E94AA7</ModuleNameOffset>
      <Before>
        <Byte>C8</Byte>
        <Byte>CE</Byte>
        <Byte>04</Byte>
        <Byte>8B</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>89</Byte>
        <Byte>83</Byte>
        <Byte>D8</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>85</Byte>
        <Byte>C0</Byte>
        <Byte>55</Byte>
        <Byte>48</Byte>
        <Byte>BD</Byte>
      </After>
    </CodeEntry>
  </CheatCodes>
  <UserdefinedSymbols>
    <SymbolEntry>
      <Name>newmem2</Name>
      <Address>08DB0000</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>BonFireAOB</Name>
      <Address>140BE4F8B</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>BonFireAOBOriginal</Name>
      <Address>13FFF0000</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>messageRepoP</Name>
      <Address>140E1683C</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>projectile</Name>
      <Address>14063C6E4</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>projectile_ptr</Name>
      <Address>13FFF0022</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>AttackAddressToUse</Name>
      <Address>08DB0000</Address>
    </SymbolEntry>
  </UserdefinedSymbols>
  <Comments>Hotkeys:
Ctrl+N - toggle Noclip
	
</Comments>
</CheatTable>
